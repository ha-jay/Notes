# docker-desktop window 설치

## wsl 환경에서 사용
docker desktop에서 설정변경 확인
- Windows에서 **Docker Desktop** 프로그램을 실행합니다.
- 오른쪽 상단 톱니바퀴 아이콘(**Settings**)을 클릭합니다.
- **General** 탭에서 **Use the WSL 2 based engine**이 체크되어 있는지 확인합니다. (기본적으로 체크되어 있어야 함)
- 왼쪽 메뉴에서 **Resources** > **WSL integration**으로 이동합니다.
- **Enable integration with my default WSL distro**를 체크합니다.
- (중요) 아래 **Additional distros** 목록에서 현재 에러가 발생한 리눅스 배포판(예: `Ubuntu`)의 스위치를 **On**으로 켭니다.
- **Apply & Restart** 버튼을 클릭합니다.

터미널을 재시작후 wsl에서 다음 명령어 실행
```
docker --version
docker ps
```


# docker 본질
## 도커가 필요해진 이유
과거에는 서버에 프로그램을 올릴 때 Java 버전, Node 버전, 환경 변수 등을 일일이 수동으로 맞췄습니다. 이 과정에서 "내 컴퓨터에선 잘 되는데 서버에선 왜 안 되지?"라는 지옥 같은 상황이 반복됐죠. 도커는 **소프트웨어 실행에 필요한 모든 것(코드, 런타임, 라이브러리)을 '컨테이너'라는 박스에 담아** 어디서든 똑같이 실행되게 만듭니다.

## 동작방식
도커는 OS 위에 '도커 엔진'을 띄우고, 그 위에서 컨테이너들을 격리된 환경으로 실행합니다. 가상머신(VM)보다 훨씬 가벼운 이유는 OS 전체를 부팅하는 게 아니라, 호스트의 커널(핵심 기능)을 공유하면서 프로세스만 격리하기 때문입니다.

## docker run `image` - 동작방식 (컨테이너 실행)
도커는 **이미지(Image)**라는 설계도를 가져와서 **컨테이너(Container)** 라는 실제 객체를 만듭니다.
`hello-world`는 도커가 제대로 작동하는지 확인하는 가장 가볍고 표준적인 '설계도'입니다. 이를 실행함으로써 "내 컴퓨터가 도커 허브(클라우드 창고)에서 설계도를 내려받아 컨테이너를 띄울 수 있는 상태"임을 증명합니다.

- 사용자가 `docker run hello-world` 입력.
- 도커 엔진이 내 컴퓨터(Local)에 `hello-world` 이미지가 있는지 확인.
- 없다면 **도커 허브(Docker Hub)**에서 다운로드(Pull).
- 이미지를 기반으로 컨테이너를 생성하고 실행.
- 컨테이너 내부의 프로그램이 "Hello from Docker!" 메시지를 출력하고 종료.

```
docker run hello-world
```
**관전 포인트:** 중간에 `Unable to find image 'hello-world:latest' locally`라는 문구가 뜨는지 확인하세요. 이게 바로 로컬에 없어서 클라우드에서 가져오고 있다는 증거입니다!


# 이미지와 컨테이너 관리하는 방법
이제 설계도(이미지)를 어떻게 관리하고 정리하는지 배워봅시다. 집을 짓기전에(이미지생성전에) 설계도(이미지)를 보관함에 넣고 빼는 법을 알아야 합니다. 


## 도커 이미지 다루기 (Pull, List, Remove)
왜 이 과정이 필요한가?

도커 이미지는 컨테이너를 만들기 위한 **'불변의 설계도'** 입니다. 우리가 Node.js나 Java 앱을 배포할 때, 매번 코드를 복사하는 게 아니라 이 '이미지'를 주고받습니다. 내 컴퓨터에 어떤 이미지들이 쌓여 있는지 확인하고, 필요 없는 이미지를 지워 용량을 확보하는 능력은 필수입니다.

어떻게 동작하는가?
- **Pull**: 도커 허브라는 거대한 도서관에서 책(이미지)을 빌려오는 과정입니다.
- **Images (ls)**: 내 책꽂이에 어떤 책들이 꽂혀 있는지 확인하는 과정입니다.
- **Rmi (Remove Image)**: 다 읽은 책을 책꽂이에서 빼서 버리는 과정입니다.

- **이미지 목록 확인 (내 책꽂이 보기)**
    ```
    docker images
    ```
    
    _방금 실행한 `hello-world` 이미지가 목록에 보일 겁니다._
    
- **새로운 이미지 미리 가져오기 (Node.js 환경 빌려오기)**
    ```
    docker pull node:18-alpine
    ```
    
    _`alpine`은 아주 가볍게 최적화된 리눅스 버전입니다. 실무에서 아주 많이 써요!_
    
- **이미지 삭제하기 (연습)**
    ```
    docker rmi hello-world
    ```
    만약 컨테이너가 사용 중이라 삭제가 안 된다면 정상입니다. (다음 Task에서 해결법을 배웁니다!)

**실무형 팁:** 실무에서는 이미지 이름 뒤에 `:latest` 보다는 `:18-alpine` 처럼 구체적인 **태그(버전)** 를 붙이는 습관이 중요합니다. 그래야 시간이 지나도 환경이 변하지 않거든요.

## 컨테이너 제어하기 (Run, Stop, Exec, Log)
**왜 이 과정이 필요한가?** 
컨테이너는 실행 중일 수도 있고, 멈춰 있을 수도 있습니다. 서버가 갑자기 죽었을 때 원인을 파악하거나(Log), 실행 중인 서버 안에 들어가서 설정을 확인해야 할 때(Exec) 이 명령어들이 여러분의 눈과 귀가 되어줍니다.

**어떻게 동작하는가?**

- **-d (Detached)**: 컨테이너를 백그라운드에서 실행합니다. (터미널을 꺼도 서버는 계속 돌아갑니다.)
- **logs**: 컨테이너 안에서 무슨 일이 일어나는지 중계방송을 봅니다.
- **exec**: 실행 중인 컨테이너 내부에 '접속'하여 명령어를 내립니다. 마치 원격 제어 같습니다.

이번에는 아까 받아둔 `node` 이미지를 활용해 보겠습니다.

1. **백그라운드에서 실행하기 (이름은 `my-node`로 지정)**
    ```
    docker run -d --name my-node node:18-alpine sleep 3600
    ```
    
    _(참고: `sleep 3600`은 컨테이너가 바로 종료되지 않게 1시간 동안 아무것도 안 하고 켜져 있으라는 명령입니다.)_
    앷
2. **실행 중인 컨테이너 목록 확인**
    
    Bash
    
    ```
    docker ps
    ```
    
    _`my-node`가 잘 돌아가고 있나요?_
    
3. **컨테이너 내부로 들어가기 (매우 중요!)**
    
    Bash
    
    ```
    docker exec -it my-node sh
    ```
    
    _명령어 입력창이 바뀔 겁니다. `node -v`를 입력해 보세요. 내 컴퓨터가 아닌 컨테이너 안의 노드 버전이 나옵니다! 나오려면 `exit`를 입력하세요._
    
4. **컨테이너 중지 및 삭제**
    
    Bash
    
    ```
    docker stop my-node
    docker rm my-node
    ```


**실무형 예제:** 현업에서 서버 앱이 응답하지 않을 때 가장 먼저 하는 일은 `docker logs [컨테이너명]`을 입력해서 에러 메시지를 확인하는 것입니다.
# 이미지 만들기
**"내가 만든 Node.js/Java 소스 코드를 도커 이미지로 굽는 법"**을 배울 것입니다.

이것이 바로 도커의 진정한 힘입니다. 개발자가 만든 환경을 그대로 박제하여 서버로 보낼 수 있게 되죠.

**왜 이 과정이 필요한가?** 
`Dockerfile`은 도커 이미지를 만들기 위한 **'자동화 레시피'**입니다. 
"어떤 OS를 쓸 건지?", "어떤 파일을 복사할 건지?", "어떤 명령어를 실행할 건지?"를 이 파일에 적어두면, 도커는 이 레시피를 보고 똑같은 음식을 만들어내듯 이미지를 생성합니다.

**어떻게 동작하는가? (레이어 시스템)** 
Dockerfile의 한 줄 한 줄은 **레이어(Layer)**라고 불리는 층을 이룹니다. 
도커는 이 레이어를 쌓아 올리는데, 변경되지 않은 레이어는 재사용(캐싱)하기 때문에 빌드 속도가 엄청나게 빠릅니다.

**나만의 Node.js 레시피 만들기** 연습을 위해 윈도우 폴더 하나를 만들고(`docker-test`), 그 안에 이름이 정확히 `Dockerfile`인 파일을 하나 만드세요. (확장자 없음) 그리고 아래 내용을 복사해서 붙여넣으세요.

```
# 1. 베이스 이미지 선택 (주방의 기본 도구 세팅)
FROM node:18-alpine

# 2. 컨테이너 내부 작업 디렉토리 설정 (주방 도마 위치)
WORKDIR /app

# 3. 내 컴퓨터의 소스 코드를 컨테이너 안으로 복사 (식재료 옮기기)
# 현재 폴더(.)의 모든 파일을 컨테이너 내부(/app)로 복사
COPY . .

# 4. 필요한 라이브러리 설치 (조리 시작)
# 실무 예시: RUN npm install

# 5. 컨테이너가 시작될 때 실행할 명령 (음식 내놓기)
CMD ["node", "-v"]
```

**실무형 팁:** Java(Spring Boot) 개발자라면 `FROM openjdk:17-jdk-alpine`으로 시작하고 `CMD ["java", "-jar", "app.jar"]`를 사용하면 됩니다. 원리는 똑같습니다!



## 이미지를 직접 빌드하고 컨테이너로 띄우기
작성한 `Dockerfile`은 그저 텍스트 파일일 뿐입니다. `docker build` 명령어를 통해 이를 실행 가능한 **바이너리 이미지**로 변환해야 합니다. 
일단 이미지가 만들어지면, 여러분은 전 세계 어디든 이 이미지 하나만 보내서 똑같은 환경을 즉시 실행할 수 있게 됩니다.

**어떻게 동작하는가?**

- **Build Context**: `docker build`를 실행할 때 현재 디렉토리의 파일들을 도커 엔진으로 보냅니다.
- **Tag (-t)**: 이미지에 이름을 붙여주는 작업입니다. 이름이 없으면 나중에 찾기 힘들겠죠?

**내 첫 커스텀 이미지 빌드하기** 터미널에서 `Dockerfile`이 있는 폴더로 이동한 뒤, 아래 명령어를 입력하세요.

1. **이미지 빌드 (이름은 `my-first-app`으로 지정)**
    
    ```
    docker build -t my-first-app .
    ```
    
    _(주의: 맨 뒤의 점(`.`)은 "현재 폴더에 있는 Dockerfile을 써라"는 뜻으로 아주 중요합니다!)_
    
2. **빌드된 이미지 확인**
    
    ```
    docker images
    ```
    
    _목록에 `my-first-app`이 생겼나요?_
    
1. **내 이미지로 컨테이너 실행**
    
    ```
    docker run my-first-app
    ```
    
    _우리가 아까 CMD에 적어둔 대로 노드 버전(예: `v18.x.x`)이 화면에 출력되고 종료된다면 성공입니다!_

**실무형 예제:** 실제 개발 팀에서는 소스 코드를 수정할 때마다 이 `build` 과정을 거쳐 새로운 버전을 만듭니다. (예: `my-first-app:v1`, `my-first-app:v2`)


# 데이터와 네트워크
## 포트 포워딩을 통해 브라우저에서 내 앱 접속하기
**1. 왜 이 과정이 필요한가?** 도커 컨테이너는 기본적으로 **완벽하게 격리된 방**입니다. 컨테이너 내부에서 8080번 포트로 서버를 띄워도, 외부(내 컴퓨터 브라우저)에서는 그 방 안을 들여다볼 수 없습니다. 이때 내 컴퓨터의 포트와 컨테이너의 포트를 연결해 주는 **'터널'**을 뚫어줘야 하는데, 이것을 **포트 포워딩(Port Forwarding)**이라고 합니다.

**2. 어떻게 동작하는가?** `-p [내 컴퓨터 포트]:[컨테이너 내부 포트]` 옵션을 사용합니다. 예를 들어 `-p 80:3000`이라고 하면, 내가 브라우저에 `localhost:80`을 입력했을 때 도커가 그 신호를 낚아채서 컨테이너 안의 `3000`번 포트로 전달해 줍니다.

**3. 실습: 가짜 웹 서버 띄워보기** 실제로 웹 서버 이미지를 가져와서 브라우저로 접속해 봅시다. 세상에서 가장 유명한 웹 서버인 `nginx`를 이용하겠습니다.

1. **포트 8080으로 연결하여 실행**
    
    Bash
    
    ```
    docker run -d -p 8080:80 --name my-web nginx
    ```
    
    _(내 컴퓨터의 8080 포트를 컨테이너의 80 포트와 연결하겠다는 뜻입니다.)_
    
2. **브라우저에서 확인** 크롬이나 엣지를 열고 주소창에 아래를 입력하세요. `http://localhost:8080`
    
3. **결과 확인** "Welcome to nginx!"라는 문구가 뜨나요? 그렇다면 성공입니다!


**실무형 팁:** Java Spring Boot 앱을 개발한다면 보통 컨테이너 내부가 8080을 쓰므로 `-p 8080:8080` 처럼 똑같이 맞춰주는 경우가 많습니다.

## 도커 볼륨을 이용해 소스 코드 실시간 변경 반영하기
**왜 이 과정이 필요한가?** 
도커 이미지는 한 번 구우면 변하지 않는 '박제'된 상태입니다. 코드를 수정해도 이미 실행 중인 컨테이너 안의 파일은 바뀌지 않죠. **볼륨(Volume)**은 내 컴퓨터의 특정 폴더와 컨테이너 내부의 폴더를 **실시간으로 동기화(연결)**합니다. 덕분에 소스 코드를 수정하면 빌드 없이도 컨테이너에 즉시 반영됩니다.

**2. 어떻게 동작하는가? (바인드 마운트)** `-v [내 컴퓨터 경로]:[컨테이너 내부 경로]` 옵션을 사용합니다. 거울처럼 내 컴퓨터 폴더의 변화를 컨테이너가 그대로 비추게 만드는 원리입니다.

**3. 실습: 실시간 동기화 체험하기** 아까 만든 `docker-test` 폴더에서 진행합니다.

1. **기존 컨테이너 삭제 (정리)**
    
    Bash
    
    ```
    docker stop my-web
    docker rm my-web
    ```
    
2. **내 폴더를 연결하여 실행** (Nginx의 기본 페이지 경로를 내 폴더로 연결)
    
    Bash
    
    ```
    # 윈도우 PowerShell 기준 (현재 경로를 $PWD로 표현)
    docker run -d -p 8080:80 --name my-vol-web -v ${PWD}:/usr/share/nginx/html nginx
    ```
    
3. **파일 만들기** `docker-test` 폴더에 `index.html` 파일을 만들고 아무 내용이나 적어보세요. (예: `<h1>Docker is Magic!</h1>`)
    
4. **브라우저 확인** `http://localhost:8080`에 접속하면 내가 방금 쓴 글자가 보일 겁니다! 이제 파일을 수정하고 저장한 뒤 브라우저를 새로고침해 보세요. **빌드 없이 바로 바뀝니다!**

**실무형 팁:** 개발 환경(Local)에서는 볼륨을 써서 빠르게 코딩하고, 실제 서버에 배포(Production)할 때는 모든 소스가 포함된 이미지를 구워서 나가는 것이 정석입니다.


# 멀티컨테이너 관리
컨테이너를 하나씩 자유자재로 다루는 **중급 이상의 숙련도**를 갖추게 되었습니다.

하지만 실제 서비스는 혼자 돌아가지 않습니다. **Node.js 앱**이 있으면 데이터를 저장할 **DB(MySQL, MongoDB 등)**가 세트로 필요하죠. 매번 명령어를 두세 개씩 치는 건 너무 피곤한 일입니다. 이걸 해결해 주는 게 바로 도커의 꽃, **Docker Compose**입니다.

## Docker Compose로 App과 DB 연결하기

**왜 이 과정이 필요한가?** 
`Docker Compose`는 여러 개의 컨테이너를 **하나의 설정 파일(`yaml`)** 에 정의하고, 명령 한 번으로 동시에 띄우는 도구입니다. "웹 서버는 8080 포트를 쓰고, DB는 3306 포트를 써라. 그리고 둘은 서로 같은 네트워크에 있어라!"라고 적어둔 **오케스트라 악보**와 같습니다.

**2. 어떻게 동작하는가?** 
`docker-compose.yml`이라는 파일을 작성한 뒤, `docker-compose up` 명령어를 입력하면 도커가 알아서 이미지 다운로드, 네트워크 설정, 볼륨 연결, 실행까지 한꺼번에 처리합니다.

**3. 실습: App과 DB 한 번에 띄우기 (예시)** 
`docker-test` 폴더에 `docker-compose.yml` 파일을 만들고 아래 내용을 복사해 보세요. (실제로 DB를 설치하지 않아도 도커가 알아서 다 해줍니다!)

YAML

```
version: '3.8'
services:
  # 우리 앱 (가상)
  my-app:
    image: node:18-alpine
    command: sh -c "echo 'App is running...' && sleep 3600"
    ports:
      - "3000:3000"

  # 데이터베이스 (실제 MySQL 이미지 사용)
  my-db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: password123
    ports:
      - "3306:3306"
```

- **실행 명령어:** `docker-compose up -d`
    
- **확인:** `docker ps`를 치면 두 개의 컨테이너가 동시에 뜨는 것을 볼 수 있습니다.
    
- **종료 명령어:** `docker-compose down` (깔끔하게 다 지워줍니다!)

**실무형 팁:** 실무에서는 `docker run`을 직접 쓰는 일보다 `docker-compose.yml`을 관리하는 일이 훨씬 많습니다. 팀원들에게 이 파일 하나만 주면 모두가 똑같은 개발 환경을 1초 만에 구축할 수 있거든요.


