# WSL환경에서 NODEJS 구축

WSL(Windows Subsystem for Linux) 환경에서 Node.js를 설정할 때 가장 권장되는 방법은 **NVM(Node Version Manager)** 을 사용하는 것입니다. 
윈도우용 설치 파일을 쓰는 대신 NVM을 사용해야 나중에 권한 문제(sudo) 없이 여러 버전을 자유롭게 바꿀 수 있습니다.

## NVM(Node Version Manager) 설치

터미널(Ubuntu 등)을 열고 아래 명령어를 입력하여 NVM 설치 스크립트를 다운로드하고 실행합니다.


```
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
```

설치가 끝나면 변경 사항을 적용하기 위해 터미널을 완전히 껐다 켜거나 아래 명령어를 입력하세요.


```
source ~/.bashrc
```




## Node.js 설치 및 확인

이제 NVM을 통해 원하는 버전의 Node.js를 설치합니다. 실무에서는 안정적인 **LTS(Long Term Support)** 버전을 주로 사용합니다.

- **최신 LTS 버전 설치:**
    
    ```
    nvm install --lts
    ```
    
- **설치 확인 (버전 체크):**
```
    node -v  # v20.x.x 와 같은 결과 출력
    npm -v   # npm 버전 출력
```

## 일반설치와 nvm 설치의 차이점
### 일반적인 설치 방식 (`sudo apt install nodejs`)

- **설치 경로:** `/usr/local/bin` 또는 `/usr/bin`
    
- **권한 문제:** 이 경로는 **시스템 관리자(root)**만 수정할 수 있는 공용 영역입니다.
    
- **결과:** 글로벌 패키지(`npm install -g`)를 설치할 때 시스템 영역에 파일을 써야 하므로 반드시 `sudo` 권한이 필요합니다. 만약 권한 없이 실행하면 `EACCES` 에러가 발생합니다.

### NVM을 통한 설치 방식

- **설치 경로:** `~/.nvm/versions/node/v20.x.x/bin` (사용자 홈 디렉토리)
    
- **권한 문제:** 홈 디렉토리(`~`)는 현재 로그인한 **사용자 본인**이 모든 권한을 가진 개인 영역입니다.
    
- **결과:** 내 방에 가구를 들여놓는 것과 같아서 관리자의 허가(`sudo`) 없이도 마음껏 패키지를 설치하거나 삭제할 수 있습니다.

왜 `sudo`를 쓰지 않는 것이 "안전"한가요?

실무에서 `npm install -g` 시 `sudo`를 남발하면 다음과 같은 위험이 있습니다.

1. **보안 위험:** npm 패키지 중에는 악성 스크립트가 포함된 경우가 있을 수 있습니다. `sudo`로 설치하면 이 스크립트가 내 시스템 전체(root)를 장악할 권한을 갖게 됩니다.
    
2. **권한 꼬임:** 특정 패키지를 `sudo`로 설치하면 그 과정에서 생성된 파일들의 소유권이 `root`로 바뀝니다. 나중에 일반 사용자로 실행하려고 할 때 "권한 없음" 오류가 계속 발생하여 개발 환경이 엉망이 될 수 있습니다.
    
3. **시스템 안정성:** 시스템 기본 경로의 파일을 건드리지 않으므로, Node.js 설정이 OS 자체의 중요 파일과 충돌할 일이 없습니다.

### NVM 작동원리
NVM은 Node.js를 사용자의 홈 디렉토리에 몰래(?) 설치한 뒤, 터미널이 실행될 때 **환경 변수(`PATH`)**를 조작하여 "시스템 기본 Node 대신 내 폴더에 있는 Node를 먼저 써라!"라고 지시합니다.

- **관리자 영역:** `/usr/bin` (건드리지 않음)
- **사용자 영역:** `~/.nvm` (여기서 모든 작업 발생)

```
which node
# 결과 예시: /home/사용자명/.nvm/versions/node/v20.11.0/bin/node
```
### 실무 효율을 높이는 추가 설정
💡 글로벌 패키지 설치 위치 해결

NVM을 쓰면 자동으로 사용자 폴더에 설치되므로, `npm install -g` 시 `sudo`를 붙이지 않아도 되어 매우 안전하고 편리합니다.

💡 패키지 매니저 pnpm 또는 yarn (선택)

최근 실무에서는 `npm`보다 빠르고 저장 공간을 아껴주는 `pnpm`을 많이 씁니다.

## VS CODE 연동
WSL에서 작업할 때는 윈도우의 VS Code를 그대로 사용하되, **'WSL' 확장 프로그램**을 설치해야 합니다.

1. VS Code 실행 후 왼쪽 확장(Extensions) 탭에서 **WSL** 검색 후 설치.
2. 터미널에서 프로젝트 폴더로 이동 후 `code .` 입력.
3. VS Code 하단 바에 **WSL: Ubuntu**라고 뜨면 성공입니다.

### ⚠️ 주의사항

- **파일 저장 위치:** 소스 코드는 반드시 WSL 내부 경로(예: `~/projects/...`)에 두세요. 윈도우 경로(`/mnt/c/...`)에서 작업하면 파일 감시 기능이나 성능이 매우 떨어집니다.
    
- **Vim 유저라면:** 앞서 설정한 `.vimrc`에 Javascript 문법 강조 플러그인을 추가하면 WSL 환경에서 환상적인 개발 환경이 완성됩니다!


## hello world

```
console.log("hello node world");
```

```
node helloworld.js
hello node world
```

## 패키지매니저

### npm
npm은 말 그대로 패키지를 **관리(Manage)**하는 도구입니다.

- **주요 역할:** 라이브러리를 내 컴퓨터나 프로젝트 폴더에 **다운로드하고 저장**합니다.
- **작동 방식:** `npm install`을 실행하면 `node_modules`라는 폴더를 만들고 그 안에 패키지 파일들을 물리적으로 저장합니다.
- **사용 예시:**

- `npm install lodash`: 내 프로젝트에서 `lodash` 기능을 쓰기 위해 설치.
    
- `npm install -g vim-anywhere`: 시스템 전역에 도구를 설치.

### npx
npx는 패키지를 **실행(Execute)**하는 도구입니다. npm 5.2 버전부터 기본 포함되었습니다.

- **주요 역할:** 패키지를 내 컴퓨터에 영구적으로 설치하지 않고, **임시로 다운로드하여 실행한 뒤 바로 삭제**합니다.
- **작동 방식:** 실행하려는 도구가 내 컴퓨터에 있는지 확인한 후, 없으면 최신 버전을 내려받아 실행하고 끝냅니다.
- **사용 예시:**

- `npx create-react-app my-app`: 리액트 초기 설정 도구는 자주 쓰지 않으므로 설치 없이 바로 실행만 함.
- `npx http-server`: 현재 폴더를 웹 서버로 잠깐 띄우고 싶을 때 사용.

### npm vs npx
|**특징**|**npm**|**npx**|
|---|---|---|
|**설치 여부**|`node_modules`에 영구 저장|실행 후 사라짐 (일회성)|
|**저장 공간**|디스크 용량을 계속 차지함|용량을 거의 차지하지 않음|
|**버전 관리**|특정 버전을 고정해서 설치함|항상 **최신 버전**을 가져와 실행함|
|**사용 목적**|프로젝트 의존성(라이브러리) 관리|일회성 도구 실행, 실행 파일 호출|

### 패키지 프로젝트에설치 vs 전역에 설치
패키지를 **내 프로젝트에 설치(Local)**할지, **시스템 전역에 설치(Global)**할지는 해당 패키지를 '코드의 부품'으로 쓸 것인지 '독립된 도구'로 쓸 것인지에 따라 결정됩니다.

1. 내 프로젝트에 설치 (Local Install)

가장 권장되는 방식이며, 실무 프로젝트의 99%는 이 방식을 사용합니다.

- **명령어:** `npm install <패키지명>`
    
- **저장 위치:** 현재 폴더의 `node_modules/` 폴더 안.
    
- **특징:**
    
    - **프로젝트별 독립성:** A 프로젝트는 React v17, B 프로젝트는 React v18을 써도 서로 간섭이 없습니다.
        
    - **공유 용이성:** `package.json`에 기록되므로, 다른 개발자가 내 코드를 받았을 때 `npm install`만 치면 똑같은 환경이 구축됩니다.
        
- **주요 대상:** `express`, `react`, `lodash`, `axios` 등 내 코드에서 `import`하여 사용하는 라이브러리.
    

---

2. 시스템 전역에 설치 (Global Install)

내 컴퓨터 어디에서나 명령어로 실행하고 싶은 도구를 설치할 때 사용합니다.

- **명령어:** `npm install -g <패키지명>`
    
- **저장 위치:** (NVM 사용 시) `~/.nvm/versions/node/.../lib/node_modules`.
    
- **특징:**
    
    - **시스템 도구화:** 터미널 어디에서나 해당 이름을 명령어로 바로 실행할 수 있습니다.
        
    - **코드에서 사용 불가:** 전역 설치된 패키지는 내 코드에서 `require`나 `import`로 불러올 수 없습니다.
        
- **주요 대상:** `nodemon`(자동 재시작 도구), `typescript`(컴파일러), `pm2`(프로세스 관리자) 등 개발 편의 도구.

비교 요약

|**구분**|**프로젝트 내 설치 (Local)**|**시스템 전역 설치 (Global)**|
|---|---|---|
|**명령어**|`npm install`|`npm install -g`|
|**관리 파일**|`package.json`에 기록됨|기록 안 됨 (컴퓨터에 귀속)|
|**사용 방식**|코드 내부에서 `import`|터미널에서 명령어(`CLI`)로 실행|
|**공동 작업**|팀원과 동일한 버전 유지 가능|팀원마다 직접 설치해야 함|
💡 실무자의 선택 기준

**"웬만하면 로컬(프로젝트 내)에 설치하세요."**

전역 설치를 하면 시간이 지나면서 내 컴퓨터의 패키지 버전들이 꼬이거나, "내 컴퓨터에선 되는데 왜 네 컴퓨터에선 안 돼?"라는 문제가 발생하기 쉽습니다.

- **팁:** 전역 도구가 필요할 때는 전역 설치 대신 앞에서 배운 **`npx`**를 사용하면 설치 없이 필요할 때만 최신 버전 도구를 쓸 수 있어 더 안전합니다.

## pnpm - 진화된 패키지 매니저
pnpm은 **performant npm**의 약자로, npm과 yarn의 고질적인 문제인 **속도와 중복 저장 공간** 문제를 해결한 도구입니다.

핵심 특징

- **저장 공간 절약 (Content-addressable storage):** 프로젝트가 100개라도 동일한 버전의 라이브러리는 내 컴퓨터에 **딱 한 번만 저장**됩니다. 나머지는 하드 링크(Hard link)로 연결하여 용량을 거의 차지하지 않습니다.
    
- **압도적인 속도:** 이미 설치된 패키지를 재사용하기 때문에 `install` 속도가 npm보다 훨씬 빠릅니다.
    
- **엄격한 의존성 관리:** 내가 설치하지 않은 "유령 의존성(Phantom dependencies)"을 코드에서 몰래 사용하는 것을 방지하여 예기치 못한 에러를 차단합니다.

### 설치 및 사용법
```
# NVM 환경에서 전역 설치
npm install -g pnpm

# 패키지 설치 시 (npm 대신 사용)
pnpm install
pnpm add <패키지명>
```



# 빌드툴

우리가 작성한 최신 자바스크립트나 리액트 코드는 웹 브라우저가 바로 읽기에 너무 복잡하거나 무겁습니다. 
빌드 도구는 이 소스 코드를 **브라우저가 가장 좋아하는 형태(표준 JS, CSS, HTML)로 가공하고 묶어주는 '공장'** 역할을 합니다.

- **코드 변환:** 최신 문법을 구형 브라우저에서도 돌아가게 바꿈.
- **파일 압축:** 불필요한 공백을 제거해 파일 크기를 줄임.
- **번들링:** 수백 개의 작은 파일을 하나나 두 개의 파일로 묶음.

## 웹팩 - 전통의 강자, 꼼꼼한 포장술" deprecated

웹팩은 오랫동안 업계 표준이었던 **번들러(Bundler)**입니다.

- **방식:** 모든 파일을 하나하나 분석해서 거대한 하나의 덩어리(Bundle)로 묶습니다.
- **장점:** 매우 세밀한 설정이 가능하고, 오래된 만큼 플러그인이 방대합니다.
- **단점:** 파일이 많아지면 분석하고 묶는 시간이 **너무 오래 걸립니다.** 개발 서버를 켤 때 커피 한 잔 마시고 와야 할 정도로 느려질 수 있습니다.

## vite "차세대 주자, 빛처럼 빠른 속도"

Vite는 프랑스어로 '빠르다'는 뜻입니다. 웹팩의 느린 속도를 해결하기 위해 등장했습니다.
- **방식:** 파일을 미리 묶지 않습니다! 브라우저가 "이 파일 줘"라고 요청할 때마다 **그 즉시 해당 파일만 보내줍니다.**
    
- **장점:**
    - **즉시 시작:** 서버를 켜자마자 바로 뜹니다.
    - **초고속 수정:** 코드 한 줄 바꾸면 화면에 0.1초 만에 반영됩니다(HMR).
- **단점:** 아주 구형 브라우저(IE 등) 지원 설정이 웹팩보다 까다로울 수 있습니다.


# REACT 프로젝트 생성

`create-react-app`(CRA)은 이제 구식(Legacy) 방식

npx create-react-app my-app (전통적 방식)
- - **도구**: Webpack 기반의 리액트 공식 초기화 도구입니다.
    
- **작동 방식**: `npx`를 사용해 일회성으로 도구를 내려받아 실행합니다.
    
- **특징**:
    
    - 모든 설정을 내부에 숨겨두어 초보자가 쓰기 편하지만, 수정이 어렵습니다.
        
    - **치명적 단점**: Webpack 기반이라 프로젝트가 커질수록 빌드와 수정 반영(HMR) 속도가 매우 느려집니다. 현재는 리액트 공식 문서에서도 이 방식보다 Vite나 Next.js를 권장합니다


pnpm create vite (최신 권장 방식) 🚀

- **도구**: 차세대 빌드 도구인 **Vite**를 사용합니다.
    
- **작동 방식**: `pnpm`의 효율적인 패키지 관리와 `Vite`의 압도적인 속도를 결합합니다.
    
- **특징**:
    
    - **속도**: `CRA`보다 개발 서버 구동이 최대 10~100배 빠릅니다.
        
    - **유연성**: 리액트뿐만 아니라 Vue, Svelte, Vanilla JS 등 다양한 템플릿을 선택할 수 있습니다.
        
    - **최신 표준**: 브라우저의 기본 기능을 활용하여 불필요한 번들링 과정을 생략합니다.


# NEXT JS 프로젝트 생성 

Next.js는 `create-next-app`이라는 공식 CLI 도구를 제공합니다. 터미널에서 아래 명령어를 실행하세요.

Bash

```
pnpm create next-app@latest
```

실행 후 나타나는 대화형 설정에서 다음과 같이 선택하는 것을 추천합니다 (대부분 엔터):

- **Project name:** 프로젝트 이름 (예: `my-next-app`)
    
- **TypeScript:** Yes (실무 표준)
    
- **ESLint:** Yes (코드 품질 관리)
    
- **Tailwind CSS:** Yes (스타일링 표준)
    
- **src/ directory:** Yes (코드 정리 용이)
    
- **App Router:** **Yes** (Next.js의 핵심이자 최신 방식)
    
- **Import alias:** Yes (`@/*` 경로 사용)

