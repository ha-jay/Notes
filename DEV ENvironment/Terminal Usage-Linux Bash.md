터미널은 소통하는 통로일 뿐이고, 운영체제와 그에 따른 shell의 종류에 따라 특징이 달라집니다.  기본SHELL의 종류와 커널의 종류, 패키지매니저등 Windows(windows NT), MacOS(UNIX), 리눅스(UNIX-LIKE) OS에 따라서 특징이 달라집니다. 


운영체제마다 터미널이 다르지만, 개발자들이 결국 우분투 터미널을 공부하는 이유는 **'이식성'** 때문입니다.

- 내 컴퓨터가 윈도우여도 **서버**는 리눅스인 경우가 99%입니다.
- **WSL2**를 쓰면 윈도우 환경에서도 우분투 터미널을 그대로 쓸 수 있습니다.
- 명령어 한 줄(`ls`, `cd`, `grep` 등)로 파일을 찾고 서버를 제어하는 문법이 전 세계 공용어처럼 쓰입니다.

우리는 개발을 할것이므로 리눅스 OS의 Bash shell 의 사용법을 알아볼것입니다. 


# bash command line 설명
![[Pasted image 20260203155342.png]]
- goose 는 linux account를 의미한다. 
- @는 symbol이다. 
- @다음에는 system name이 온다. 
- : 다음에는 사용자의 위치를 알려준다. `~`는 현재 home/goose 디렉토리에 있는것을 의미한다. 

# 명령어의 종류
- **외부 명령어 (External):** 별도의 실행 파일로 존재하는 도구 (예: `ls`, `mkdir`, `pwd`) -> **`man`** 사용
- **내장 명령어 (Built-in):** 쉘(Bash) 프로그램 안에 아예 포함되어 있는 기초 명령어 (예: `cd`, `exit`, `alias`, `help`) -> **`help`** 사용

# bash cheat sheet

https://devhints.io/bash - bash commands cheat sheet

# 기호 설명
### `> / >>` - 명령어 실행결과를 리다이렉션

`>`와 `>>`는 명령어의 실행 결과를 파일로 보내는 **리다이렉션(Redirection)** 기구입니다. 쉽게 말해, 화면에 나올 글자를 파일에 '저장'하는 화살표라고 생각하시면 됩니다.
두 기호의 결정적인 차이는 **'덮어쓰느냐'** 아니면 **'뒤에 붙이느냐'**입니다.

1. `>` (덮어쓰기 - Overwrite)

명령어의 결과를 파일로 보낼 때, 기존 파일 내용이 있다면 **전부 지우고 새로 작성**합니다. 파일이 없으면 새로 만듭니다.

- **용도:** 설정 파일을 새로 만들거나, 기존 로그를 초기화하고 새로 기록할 때 사용합니다.
    
- **예시:**
    
    ```
    echo "Hello Kitty" > practice.txt
    ```
    
    > 결과: `practice.txt`의 기존 내용은 다 사라지고 "Hello Kitty"만 남습니다.
    

---
 2. `>>` (추가하기 - Append)

명령어의 결과를 기존 파일의 **맨 마지막 줄 뒤에 덧붙입니다.** 기존 내용은 그대로 보존됩니다.

- **용도:** 로그 파일을 누적해서 기록하거나, 기존 설정 파일 아래에 설정을 추가할 때 사용합니다.
    
- **예시:**
    
    ```
    echo "Meow Meow" >> practice.txt
    ```
    
    > 결과: "Hello Kitty" 아래에 "Meow Meow"가 한 줄 추가됩니다.


### `< / <<` - 입력 리다이렉션

쉽게 말해 **"키보드로 칠 내용을 파일이나 텍스트 덩어리로 대신 넣어줄게!"** 라고 보시면 됩니다.

1. `<` (입력 리다이렉션)

파일의 내용을 명령어로 집어넣을 때 사용합니다. 보통 `grep`이나 `cat`은 파일명을 인자로 받지만, 어떤 명령어들은 표준 입력만 받을 때가 있는데 그때 요긴합니다.

- **동작:** `명령어 < 파일명`
    
- **예시:**
    
    ```
    wc -l < practice.txt
    ```
    
    > **차이점:** `wc -l practice.txt`라고 치면 파일 이름도 같이 출력되지만, `<`를 쓰면 순수하게 **숫자(줄 수)**만 나옵니다. (파일 내용을 입력값으로만 처리했기 때문입니다.)
    

 2. `<<` (Here Document)

이건 좀 특이한데, **"지정한 글자가 나올 때까지 내가 지금 치는 모든 것을 입력으로 넣어라"** 라는 뜻입니다. 보통 스크립트 안에서 여러 줄의 텍스트를 한꺼번에 파일로 만들거나 전달할 때 사용합니다.

- **동작:** `명령어 << 종료구문` ... (내용) ... `종료구문`
    
- **예시 (앞서 사용했던 방식):**
    
    ```
    cat <<EOF > test.txt
    첫 번째 줄입니다.
    두 번째 줄입니다.
    EOF
    ```
    
    > 여기서 `EOF`(End Of File)는 "이제 끝낼게"라는 약속된 신호입니다. (꼭 EOF가 아니어도 `STOP`이나 `END` 등 아무 단어나 써도 됩니다.)
    

---

### | - piping
앞 명령어의 **출력(결과)**을 뒤 명령어의 **입력**으로 바로 넘겨줄 때 사용합니다. 여러 명령어를 한 줄로 엮어서 강력한 기능을 수행하게 합니다.

- **의미:** "A의 결과를 가지고 B를 해라"
    
- **예시:** `cat practice.txt | grep "kitty" | wc -l`
    
    1. `cat`으로 파일을 읽어서 화면에 뿌리는 대신 **파이프로 보냄.**
        
    2. `grep`이 그 내용을 받아서 "kitty"가 있는 줄만 골라내고 **다시 파이프로 보냄.**
        
    3. `wc -l`이 최종적으로 넘어온 줄의 개수만 세어서 **화면에 출력.**


# 도움말 help, man, whatis

help와 man 명령어가 있습니다. 

- help는 쉘 내장 명령어(Shell Built-in commands)' 전용 설명서입니다. **간략하고 핵심만 설명**합니다. **옵션**이 무엇인지 알려줍니다. 
- man은  모든 명령어 (External 실행 파일로 존재하는 명령어 포함)의 **상세 백과사전** 같은 설명서입니다. 명령어의 유래부터 모든옵션의 상세설명까지 상세하게 나옵니다. 

도움말 명령어 3가지 방법 어떤 도움말을 쓸까?
- `명령어 --help` : 가장 먼저 시도하세요. 대부분의 명령어에서 작동하며 핵심 요약을 보여줍니다.
- **`man 명령어`**: 가장 확실한 방법입니다. 거의 모든 명령어의 **상세 백과사전**을 보여줍니다.
- `help 명령어` : 기본 내장 명령어가 궁금할 때 사용하세요.

`whatis` 명령어는 간단하게 한줄로 명령어가 무엇인지 파악합니다.
![[Pasted image 20260203162630.png]]

### man 사용법 - 심화
- 조작법
		- - **화살표 위/아래:** 한 줄씩 이동
		- **Space:** 한 페이지씩 이동 / b 한페이지위
		- **`/단어`:** 특정 단어 찾기
		- **`q`:** 설명서 밖으로 나가기 (**중요!**)
- 화면구성
		- name : 명령이나 함수의 이름으로, 한 줄의 설명이 뒤따른다.
		- SYNOPSIS - 사용 문법입니다. 대괄호`[]`는 생략 가능,`...` 은 여러 개 입력 가능함을 뜻합니다.
		- DESCRIPTION - 명령이나 함수의 기능에 대한 텍스트 설명이다. 여러옵션들의 사용법을 알려준다.
		- eXAMPLES - 일반적인 사용법의 몇 가지 예시이다.
		- SEE ALSO - 관련 명령이나 함수의 목록이다.

man명령어는 단순히 텍스트를 보여주는 프로그램이 아니라, 시스템에 저장된 수만 개의 매뉴얼 파일을 섹션별로 관리합니다.

- **Section 1**: 일반 사용자 명령어 (ls, cd 등)
- **Section 2**: 시스템 호출 (커널이 제공하는 함수)
- **Section 3**: 라이브러리 함수 (C 언어 함수 등)
- **Section 8**: 시스템 관리용 명령어 (root 전용)

**Tip:** 
- `man 3 printf`라고 치면 C 언어의 printf 함수 설명이 나오고, `man 1 printf`라고 치면 쉘 명령어가 나옵니다.
- Defaults (기본값) - 별도의 설정이 없다면 `man`은 기본적으로 환경 변수인 `$MANPATH`에 지정된 경로에서 파일을 찾습니다. 

Options (주요 옵션)

- **`k [키워드]`**: "이름은 기억 안 나는데... 네트워크 관련이었나?" 할 때 씁니다. 해당 키워드가 포함된 모든 매뉴얼을 검색합니다. (`apropos`와 동일)
- **`f [명령어]`**: 해당 명령어에 대한 짧은 요약만 보여줍니다. (`whatis`와 동일)
- **`a`**: 검색된 모든 섹션의 매뉴얼을 순서대로 다 보여줍니다.


# 사용자정보

우분투 터미널을 켰다고 가정하고, 내 컴퓨터의 정보를 확인하는 명령어부터 시작해 볼까요?

1. `whoami`: 현재 로그인된 사용자 이름 확인
2. `uname -a`: 운영체제의 상세 정보 확인
3. `cat /etc/os-release`: 설치된 우분투의 버전 정보 확인

# 파일 및 폴더의 소유자 및 그룹 / 권한확인 및 변경

## ls -al   파일 또는 폴더의 권한을 알수있다.

아래그림에서는 권한 / 링크수 / 소유자 / 그룹  순서대로 정보가 나열됩니다. 
- 폴더는 파란색, 파일은 회색, 실행파일은 초록색입니다. 
![[Pasted image 20260203163227.png]]
리눅스는 여러 명이 한 컴퓨터에 접속해서 사용하는 **'다중 사용자 시스템'** 을 기반으로 설계되었습니다. 그래서 "누가 이 파일을 만들었나?"와 "이 파일을 같이 볼 수 있는 사람들은 누구인가?"를 명확히 구분하는 것이 매우 중요합니다.

권한은 총 10자리로 표시된다.
💡소유자란 ? - 파일이나 폴더를 **직접 만든 주인**입니다.
	- 기본적으로 소유자가 파일의 모든 권한을 가집니다.
	- 주인만이 파일의 권한(chmod)을 다른 사람에게 줄지 말지 결정할 수 있습니다.
	- **`999`**: 이름이 아니라 **UID(User ID)** 라는 고유 번호입니다. 보통 도커(Docker) 같은 프로그램이 컨테이너 내부에서 파일을 만들 때, 리눅스 시스템에 등록되지 않은 가상 사용자를 사용하면 이렇게 숫자로 표시됩니다. "이런 파일은 이 시스템의 일반 유저(goose)가 만든 게 아니라, 어떤 특정 서비스가 만든 거야"라고 이해하시면 됩니다.
💡그룹이란? - 이 파일에 접근할 권한이 있는 그룹으로써, 여러 사용자를 하나의 묶음으로 만든 단위입니다. 한 사용자는 여러 그룹에 동시에 속할 수 있습니다. dev그룹(개발팀),design그룹(디자인팀)으로 나누어 팀별로 폴더 접근 권한을 다르게 줄 수 있습니다.
	- Root group - 리눅스의 **'신'** 이라고 불리는 최고 관리자 계정입니다. 시스템의 모든 파일을 읽고 쓰고 지울 수 있습니다.
	
    - "이런 파일은 이 시스템의 일반 유저(`goose`)가 만든 게 아니라, 어떤 특정 서비스가 만든 거야"라고 이해하시면 됩니다.
💡그외란? - 소유자도아니고 그룹도 아닌사람
```bash
[폴더?파일?여부1자리][소유자권한3자리][그룹권한3자리][그외사용자권한3자리]
#ex) -rw-rw-r-- 
# -> 파일이고 / 소유자는 rw권한 / 그룹은 rw권한 / 그이외에는 r권한
```
- 제일 첫번째 문자는 폴더/파일의 여부를 알려준다.
    - 제일앞에 `-` 가 표시되면 파일
    - 제일앞에 `d` 가 표시되면 폴더
- 나머지 9글자는 3글자씩 끊어서 **[내 권한] / [그룹 권한]  / [나머지 타인 권한]** 순서입니다.
    - 권한은 rwx로 표기된다. r은 read, w는 write, x는 execute



## chmod - 권한 변경 <소유자가 누군지는 모르겠지만, 그 파일의 소유자에 대한 rwx 권한을 설정>

파일 또는 폴더의 권한을 변경할 때 사용

```bash
# 8진수 모드의경우
chmod [옵션] [소유자권한][그룹권한][그외사용자권한] [파일또는폴더]

# 문자열 모드의 경우
chmod [옵션] [레퍼런스][연산자][권한] [파일또는폴더]
```

어떤사용자에게 권한 부여하는지 설정

- u 파일 or 폴더의 소유자
- g 그룹 : 파일 또는 폴더의 그룹에 포함된사용자
- o : 그외 사용자
- a : 모든 사용자

연산자

- `+` 는 기존권한에 권한추가
- `-` 는 기존권한에서 권한제거
- `=` 지정한 권한으로 변경

예시

test.txt 파일의 권한이 `rwxrw-r--` 이라면

- 소유자의 실행권한삭제

```bash
chmod u-x test.txt
```

- 외부사용자에 쓰기, 실행 권한 부여

```bash
chmod o+wx test.txt
```

- 모든사용자에게 읽기권한만부여

```bash
chmod a=r test.txt
```

옵션 `-R`

권한을 폴더 및 하위경로에 모두적용

```bash
chmod -R 777 example_folder
```

### 소유자가 root인 경우 

만약 어떤 폴더의 권한이 `drwxr-xr-x`이고 소유자가 `root`라면, 일반 사용자인 `goose`는 이 폴더 안에 새로운 파일을 만들 수 있을까요?

- **정답:** **아니요!** 소유자(`root`)만 쓰기(`w`) 권한이 있고, 그룹과 타인은 읽기(`r`)와 실행(`x`)만 가능하기 때문에 `goose`는 폴더 안을 들여다볼 수는 있지만 파일을 만들 수는 없습니다.

**이럴 때 `sudo`를 써서 강제로 만들거나, `chown`으로 주인을 나로 바꿔야 합니다. 이 권한 변경 방법(`chmod`, `chown`)에 대해 실습해 볼까요?**


## 파일 소유자, 그룹 변경
### chown, chgrp : 파일에 대한 권한은 모르겠고, 파일의 소유자, 그룹을 변경

나중에 개발하다 보면 "권한이 없습니다(Permission Denied)"라는 메시지를 자주 보게 될 텐데, 그때 아래 명령어들을 쓰게 됩니다.

|**명령어**|**의미**|**설명**|
|---|---|---|
|**`chown`**|Change Owner|파일의 주인을 바꿉니다. (예: `sudo chown user1 file.txt`)|
|**`chgrp`**|Change Group|파일의 그룹을 바꿉니다.|
|**`id`**|ID|내가 지금 어떤 ID이고 어떤 그룹에 속해 있는지 보여줍니다.|

---
chown - 소유자와 그룹 변경

파일의 **'주인'** 자체를 바꾸는 명령어입니다. 주로 시스템 파일이나 다른 사람이 만든 파일을 내가 관리해야 할 때 사용합니다. 보통 관리자 권한(`sudo`)이 필요합니다.

- **기본 문법:** `sudo chown [소유자]:[그룹] [파일명]`
- **실제 예시:** `sudo chown goose:goose docker-compose.yaml`
    - 해당 파일의 주인을 `goose`로, 그룹도 `goose`로 바꿉니다. 이제 `goose` 사용자가 이 파일에 대해 주인의 권한을 행사할 수 있습니다.

### chmod vs chown - 왜 둘을 같이 쓸까요? 실무시나리오 - 보통은 chown을 통해 주인변경을 더 권장한다. 
개발하다 보면 이런 상황이 자주 발생합니다.

1. **문제:** `root` 사용자가 만든 설정 파일이 있어서 내가(`goose`) 수정을 못 함.
2. **방법 A (chown):** `sudo chown goose file.txt` 명령어로 파일의 주인을 나로 바꿔버립니다. 이제 내 거니까 마음대로 수정합니다.
3. **방법 B (chmod):** 주인은 `root`로 두되, `sudo chmod 666 file.txt` 명령어로 "누구나 읽고 쓸 수 있게" 문을 열어줍니다.

**보통은 보안을 위해 방법 A(주인 변경)를 더 권장합니다.**

---
chgrp - 그룹만 변경

`chown`이 주인(개인)을 바꾼다면, `chgrp`는 그 파일에 접근할 수 있는 '팀'을 바꾸는 도구입니다.

- **역할:** `chown`은 소유자와 그룹을 동시에 바꿀 수 있지만, `chgrp`는 오직 **그룹**만 전문적으로 바꿀 때 사용합니다.
- **기본 문법:** `chgrp [그룹명] [파일명]`
- **실제 예시:** `chgrp dev_team project.txt`
    - `project.txt` 파일의 그룹을 `dev_team`으로 바꿉니다. 이제 `dev_team` 그룹에 속한 사람들은 해당 파일에 설정된 '그룹 권한'에 따라 파일을 읽거나 쓸 수 있습니다.
- **특징:** 소유자가 아닌 그룹만 바꾸고 싶을 때 더 명확하게 의도를 나타낼 수 있어 유용합니다.

---
### id - 내가 누구인지, 어떤 그룹에 속해 있는지 **나의 신분증**을 확인하는 명령어


- **역할:** 터미널에 접속한 현재 사용자의 고유 번호(UID)와 소속된 그룹 번호(GID)를 보여줍니다.
- **사용법:** 터미널에 그냥 `id`라고 입력합니다.
- **결과 예시:** `uid=1000(goose) gid=1000(goose) groups=1000(goose),4(adm),27(sudo)...`
    - **uid**: 나의 고유 유저 아이디 번호입니다. uid=1000(goose) : 당신의 고유 번호(ID)는 1000번이고, 이름은 `goose`입니다. (리눅스에서 일반 사용자는 보통 1000번부터 시작합니다.)
    - **gid**: 나의 기본 그룹 아이디 번호입니다. **`gid=1000(goose)`**: 당신의 주 소속 팀(그룹)도 1000번 `goose` 팀입니다.
	- **groups**: 내가 현재 속해 있는 모든 그룹의 목록입니다. (여기 `sudo`가 있다면 관리자 권한을 쓸 수 있다는 뜻입니다.)
		- **`27(sudo)`**: **가장 중요합니다!** 당신은 `sudo` 그룹에 속해 있습니다. 즉, 언제든 관리자 권한을 빌려와 시스템 전체를 제어할 수 있는 '상급 사용자'라는 뜻입니다.
	    - **`1001(docker)`**: 당신은 도커를 다룰 수 있는 권한도 가지고 있네요.


### 실무 시나리오

실무에서는 이런 식으로 흐름이 이어집니다.

1. *`id`*를 쳐서 내가 `developers`라는 그룹에 속해 있는지 확인합니다.
2. 만약 내가 만든 파일을 우리 팀원들도 같이 수정하게 하고 싶다면, **`chgrp developers my_code.py`** 명령으로 파일의 그룹을 우리 팀으로 바꿉니다.
3. 그다음 **`chmod 664 my_code.py`*를 통해 그룹(`6`)에게도 쓰기 권한을 주면, 팀원들이 내 파일을 함께 편집할 수 있게 됩니다.


###  새로운 그룹 만들기 (`groupadd`)

새로운 그룹을 생성하려면 관리자 권한이 필요합니다. 예를 들어 `devteam`이라는 그룹을 만들어 보겠습니다.

- **명령어:** `sudo groupadd devteam`
- **설명:** `sudo`는 관리자 권한을 빌리는 것이고, `groupadd`는 그룹을 생성하는 명령어입니다.

### 나를 해당 그룹에 추가하기 (`usermod`)

이제 생성한 `devteam` 그룹에 사용자 `goose`를 참가시켜야 합니다.

- **명령어:** `sudo usermod -aG devteam goose`
- **옵션 의미:**
    - `a` (append): 기존에 속해 있던 그룹들에서 탈퇴하지 않고 '추가'하겠다는 뜻입니다. (이 옵션을 빠뜨리면 다른 그룹에서 다 쫓겨날 수 있으니 주의하세요!)
    - `G` (Groups): 추가할 그룹 목록을 지정합니다.

###  그룹 변경 사항은 **다시 로그인**해야 적용

리눅스에서 그룹 변경 사항은 **다시 로그인**해야 적용됩니다. WSL 환경에서는 아래 명령어로 현재 쉘을 갱신하거나 터미널을 완전히 껐다 켜야 합니다.

- **명령어:** `newgrp devteam`
- **설명:** 로그아웃 없이 현재 터미널 세션에 그룹 변경 사항을 즉시 적용해 줍니다.

### 결과 확인하기 (`id`)

아까 배웠던 `id` 명령어를 통해 내가 정말로 `devteam`에 들어갔는지 확인해 봅니다.

- **명령어:** `id`
- **결과 확인:** `groups=...` 목록 끝에 `100x(devteam)`이 추가되어 있다면 성공입니다!


# 출력 / 읽기 / 쓰기

## 출력 및 읽기

### echo - string 터미널 출력
```
echo hello world
```

`echo -e`
- e flag는 `\\` 백슬래쉬 이스케이프의 해석을 활성화합니다.
- echo 는 값이 “”로 묶인 경우에만 빈줄을 인쇄합니다.

```bash
echo -e "\\n~~ Questionnaire ~~\\n"
```

### more - 파일내용 출력 - 페이지단위로 끊어서 출력

```bash
codeally@2bfbc0509511:~/project/freeCodeCamp$ more package.json
{
  "name": "freecodecamp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "programmatic-test": "mocha --config .mocharc.json",
    "test": "mocha --config .mocharc.json"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "mocha": "^7.2.0",
    "mocha-tap-reporter": "^0.1.3",
    "shell-quote": "^1.7.2"
  }
}
```

`more`는 파일의 내용을 **페이지 단위**로 끊어서 보여주는 명령어입니다.

- **특징:** 파일 내용이 화면보다 길 경우, 아래쪽을 한 번에 다 보여주지 않고 멈춥니다.
- **주요 용도:** 긴 로그 파일이나 긴 코드를 읽을 때 유용합니다.
- **조작법:**
    - **Space Bar:** 다음 페이지로 넘어가기
    - **Enter:** 한 줄씩 내려가기
    - **q:** 읽기 중단하고 빠져나오기

### CAT - 파일의 내용을 터미널 화면에 한꺼번에 통째로 쏟아붓는 명령어
파일을 순서대로 읽고 그내용을 읽은 순서대로 표준출력에 쓰이는 명령

- **특징:** 파일이 짧으면 아주 편리하지만, 수천 줄짜리 긴 파일이라면 화면이 순식간에 지나가 버려서 내용을 확인하기 어렵습니다.
- **주요 용도:** * 짧은 설정 파일 확인 (`cat config.txt`)
    - 두 개 이상의 파일을 하나로 합치기 (`cat file1 file2 > combined.txt`)
    - 새로운 파일 만들기 (`cat > newfile.txt` 입력 후 내용 작성, Ctrl+D로 저장)

- OPTIONS
	- `cat -n` : 모든 줄 앞에 번호를 매겨서 출력해 줍니다. 빈 줄도 번호에 포함됩니다.
	- `cat -b` : 빈 줄을 제외하고 내용이 있는 줄에만 번호를 매기고 싶다면
	- `cat -A` : 눈에 보이지 않는 탭(Tab) 문자나 줄바꿈 문자($)를 시각적으로 확인하고 싶을 때 씁니다.줄 끝에 $표시를 붙여주는 등 보이지 않는 제어 문자를 보여줍니다. 윈도우와 리눅스 사이에서 파일 형식이 꼬였을 때 원인을 찾기 좋습니다.


# 데이터처리

## grep - 파일 안에서 특정 패턴(단어)을 포함한 줄만 찾아서 보여주는 명령어

- **기본형:** `grep [단어] [파일명]`
- **주요 옵션:**
    - `grep -i`: 대소문자 구분 없이 찾기
    - `grep -v`: 해당 단어가 **포함되지 않은** 줄만 찾기 (반전 검색)
    - `grep -n`: 몇 번째 줄에 있는지 번호와 함께 표시
    - `grep -o` : `grep`은 패턴이 발견된 **'줄(line) 전체'를 보여주지만, `-o` (--only-matching**) 옵션은 딱 **'매치된 텍스트'**만 떼어내서 보여줍니다.
    - `grep -c` : 매칭된 줄의 **개수**만 출력
    - `grep -r` : 현재 디렉토리 및 **하위 디렉토리**의 모든 파일 검색
- **예시:** `grep "error" server.log` (로그 파일에서 'error'가 포함된 모든 줄을 출력)

![[Pasted image 20260203173221.png]]

```
The little kitty said meow.
MEOW! shouted the angry kitty.
A kitten is a young kitty.
The kitty goes meow meow meow.
Meow is the sound a kitty makes.
I have a kitty, and it likes to meow at night.
meowmeow - that's a double meow.
KITTY and MEOW are in uppercase here.
The cat didn't say meow, it just stared.
My kitty's name is Meowzer.
There is no cat or sound in this line.
A soft meow came from the tiny kitty.
Just a fluffy kitty sleeping on the sofa.
The hungry kitty is waiting for food.
I heard a loud meow from the garden.
The stray cat gave a lonely meow.
It is a beautiful sunny day today.
Coding is fun and challenging.
Birds are singing in the trees.
The milk was spilled on the floor.
```

- `grep '<patten>' filename`  : - 패턴(단어)과 일치하는 모든 라인 출력
- `grep --color 'pattern' filename` : 패턴과 일치하는 단어에 색상추가되어 출력(빨간색 표기)
	![[Pasted image 20260203174331.png]]
- `grep --color -n 'pattern' filename` : 일치하는 라인이 몇번째 줄인지 표시
	![[Pasted image 20260203174511.png]]
- `grep --color -n 'regexp' filename` : 정규식사용
	![[Pasted image 20260203175226.png]]
- `grep -c 'meow[a-z]*' filename`  -c플래그는 count를 의미한다. 패턴이 일치하는 라인의 수(count)를 반환
	![[Pasted image 20260203175334.png]]
- 일치하는 모든 단어수 찾는 방법 `grep -o 'meow[a-z]*' filename` 오직 일치하는 패턴만을 1줄씩 반환
	![[Pasted image 20260203175554.png]]
- 패턴에 일치하는 단어가 몇번나오는가? `grep -o 'meow[a-z]*' filename | wc -l`  : wc는 파일의 줄수, 단어수, 바이트수를 알려주는 명령어고 `-l` 옵션은 라인의 수만 알려준다. 
	![[Pasted image 20260203175757.png]]
	
- 일치하는 단어 count숫자를 파일에 append : `grep -o 'meow[a-z]*' filename | wc -l >> filename
	![[Pasted image 20260203175920.png]]


## sort - 텍스트 파일의 내용을 알파벳순이나 숫자순으로 정렬합니다.
- **기본형:** `sort [파일명]`
- **주요 옵션:**
    - `sort -r`: 역순(Z to A) 정렬
    - `sort -n`: 문자열이 아닌 **숫자 크기** 순서대로 정렬 (중요!)
- **예시:** `sort user_list.txt` (이름들을 가나다/알파벳순으로 정렬)


## uniq (중복 제거)
연속된 중복 줄을 하나로 합쳐줍니다. 보통 `sort`와 함께 사용됩니다.

- **기본형:** `sort 파일명 | uniq`
- **주요 옵션:**
    - `uniq -c`: 중복된 횟수가 몇 번인지 앞에 숫자를 붙여줌
- **주의:** `uniq`는 바로 옆에 붙어있는 줄끼리만 비교하므로, 전체 중복을 없애려면 반드시 먼저 `sort`를 해줘야 합니다.

