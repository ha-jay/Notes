# 빌드툴이란? - 소스코드를 실행가능한 파일로 자동변환

한마디로 말해서 **패키지 관리자**로 재료를 사고, **트랜스파일러**로 다듬고, **번들러**로 포장하며, **태스크 러너**가 이 공정 전체를 가동합니다.
현대적인 프론트엔드 빌드 과정을 예로 들면 다음과 같습니다:

1. **패키지 관리자**(`npm`)가 필요한 라이브러리를 설치한다.
2. 개발자가 코드를 짜면 **린터**(`ESLint`)가 문법 오류를 잡는다.
3. **트랜스파일러**(`Babel`/`tsc`)가 최신 코드를 표준 JS로 바꾼다.
4. **모듈 번들러**(`Webpack`/`Vite`)가 모든 파일과 이미지를 하나로 묶고 압축한다.
5. 이 모든 과정이 **태스크 러너**나 빌드 스크립트에 의해 자동 실행된다.



개발을 하다 보면 단순히 코드를 쓰는 것 외에 **컴파일, 라이브러리 다운로드, 테스트, 패키징** 등 반복적으로 해야 하는 작업이 정말 많습니다.

**빌드 툴(Build Tool)** 은 이러한 일련의 과정(빌드 프로세스)을 자동으로 수행해 주는 소프트웨어입니다. 쉽게 말해, 개발자가 작성한 소스 코드를 실행 가능한 소프트웨어 결과물로 변환하는 **'자동화 공장'** 이라고 생각하시면 됩니다.



개발자가 작성한 소스 코드를 컴퓨터나 브라우저가 실행할 수 있는 **최종 소프트웨어 결과물로 변환하는 과정을 자동화**해주는 도구입니다.

개발자가 코드만 짠다고 바로 프로그램이 돌아가는 것은 아닙니다. 코드를 검사하고, 합치고, 압축하고, 테스트하는 수많은 뒷작업이 필요한데 이를 빌드 툴이 대신해 줍니다.

우리가 작성한 최신 자바스크립트나 리액트 코드는 웹 브라우저가 바로 읽기에 너무 복잡하거나 무겁습니다. 
빌드 도구는 이 소스 코드를 **브라우저가 가장 좋아하는 형태(표준 JS, CSS, HTML)로 가공하고 묶어주는 '공장'** 역할을 합니다.


# 빌드툴의 주요역활


빌드 툴은 마치 **공장의 자동화 라인**처럼 다음과 같은 복잡한 공정을 처리합니다.

- **컴파일(Compile):** 사람이 읽기 쉬운 코드(Java, TypeScript 등)를 컴퓨터가 이해하는 언어로 번역합니다. 
- **번들링(Bundling):** 수백 개의 파일로 쪼개진 소스 코드를 하나 혹은 몇 개의 파일로 묶어줍니다.
- **코드 압축(Minification):** 파일 용량을 줄이기 위해 공백을 제거하고 변수명을 짧게 바꿉니다.
- **리소스 최적화:** 이미지 크기를 줄이거나, CSS/JS 파일을 웹 브라우저가 빨리 읽을 수 있게 가공합니다.
- **테스트 자동화:** 코드가 작성된 대로 잘 작동하는지 테스트 코드를 실행합니다.
- **패키징 (Packaging):** 컴파일된 코드와 리소스 파일들을 실행 가능한 형태(`.jar`, `.war`, `.exe` 등)로 묶습니다.
- **배포 (Deployment):** 생성된 결과물을 서버나 저장소에 업로드합니다.

# 주요 빌드툴 
|**분야**|**주요 빌드 툴 및 번들러**|**특징**|
|---|---|---|
|**Frontend (JS/TS)**|**Webpack**, **Vite**, **esbuild**|브라우저 환경에 최적화된 파일(HTML, CSS, JS) 생성|
|**Java**|**Gradle**, **Maven**|대규모 프로젝트의 의존성 관리와 컴파일 특화|
|**Android**|**Gradle**|안드로이드 앱 설치 파일(APK) 생성|
|**C/C++**|**Make**, **CMake**|운영체제에 맞는 실행 파일 빌드|

|**언어 / 환경**|**대표적인 빌드 툴**|**특징**|
|---|---|---|
|**Java**|**Maven, Gradle**|안드로이드나 스프링 프로젝트에서 필수적입니다.|
|**C / C++**|**Make, CMake**|오래된 역사와 강력한 성능을 자랑합니다.|
|**JavaScript**|**Webpack, Vite, npm**|프론트엔드 자산을 번들링하고 최적화합니다.|
|**Python**|**Pip, Poetry**|패키지 관리와 가상 환경 구축에 특화되어 있습니다.|

### 🤔 빌드 툴을 왜 써야 하나요?

만약 빌드 툴이 없다면, 라이브러리가 업데이트될 때마다 직접 파일을 다운로드해서 경로를 지정해야 하고, 수백 개의 파일을 일일이 수동으로 컴파일해야 합니다. 빌드 툴을 사용하면 **"누가, 어디서 빌드하든 동일한 결과물"**이 나오는 재현성을 확보할 수 있고, 개발 시간을 획기적으로 줄일 수 있습니다.

혹시 지금 배우고 계신 프로그래밍 언어나 관심 있는 프로젝트가 있으신가요? 그 환경에 딱 맞는 빌드 툴을 추천해 드릴 수 있습니다.

# 프론트엔드 빌드툴
## 웹팩 - 전통의 강자, 꼼꼼한 포장술" deprecated

웹팩은 오랫동안 업계 표준이었던 **번들러(Bundler)**입니다.

- **방식:** 모든 파일을 하나하나 분석해서 거대한 하나의 덩어리(Bundle)로 묶습니다.
- **장점:** 매우 세밀한 설정이 가능하고, 오래된 만큼 플러그인이 방대합니다.
- **단점:** 파일이 많아지면 분석하고 묶는 시간이 **너무 오래 걸립니다.** 개발 서버를 켤 때 커피 한 잔 마시고 와야 할 정도로 느려질 수 있습니다.



## vite "차세대 주자, 빛처럼 빠른 속도"

Vite는 프랑스어로 '빠르다'는 뜻입니다. 웹팩의 느린 속도를 해결하기 위해 등장했습니다.
- **방식:** 파일을 미리 묶지 않습니다! 브라우저가 "이 파일 줘"라고 요청할 때마다 **그 즉시 해당 파일만 보내줍니다.**
    
- **장점:**
    - **즉시 시작:** 서버를 켜자마자 바로 뜹니다.
    - **초고속 수정:** 코드 한 줄 바꾸면 화면에 0.1초 만에 반영됩니다(HMR).
- **단점:** 아주 구형 브라우저(IE 등) 지원 설정이 웹팩보다 까다로울 수 있습니다.

## 웹팩 vs vite
### 1. 개발 서버 기동 방식: "필요할 때만 가져온다"

기존의 빌드 툴(Webpack)과 Vite의 가장 큰 차이점은 **'언제 번들링을 하느냐'**입니다.

 Webpack (기존 방식)

- **방식:** 서버를 띄우기 전에 프로젝트의 모든 파일(수백~수천 개)을 하나로 합치는(Bundling) 과정을 거칩니다.
    
- **문제점:** 프로젝트 규모가 커질수록 이 '합치는 시간'이 길어져서, 명령어 입력 후 실제 화면이 뜨기까지 몇 분씩 걸리기도 합니다.
    

 Vite (최신 방식)

- **방식:** **Native ESM(ES Modules)**을 활용합니다. 서버를 띄울 때 번들링을 하지 않고 바로 실행합니다.
    
- **원리:** 브라우저가 "A 파일 줘!"라고 요청하면, Vite는 그 순간 그 파일만 가공해서 전달합니다. 즉, **브라우저가 번들러 역할의 일부를 대신 수행**하는 것입니다.
    

---

### 2. 의존성 사전 빌드 (Dependency Pre-bundling)

"그럼 라이브러리가 엄청 많아지면 브라우저가 수천 번 요청하느라 느려지지 않나요?"라는 의문이 생길 수 있습니다. 이를 해결하기 위해 Vite는 **esbuild**를 사용합니다.

- **사전 빌드:** 자주 바뀌지 않는 외부 라이브러리(`lodash`, `react` 등)는 서버를 처음 켤 때 **Go 언어로 작성된 매우 빠른 esbuild**로 미리 합쳐버립니다.
    
- **효과:** 수많은 HTTP 요청이 발생하는 것을 방지하고, 이후에는 캐시된 파일을 사용하여 로딩 속도를 극대화합니다.
    

---

### 3. 소스 코드 업데이트 (HMR)

코드를 수정했을 때 화면에 반영되는 **HMR(Hot Module Replacement)** 방식도 다릅니다.

- **기존:** 파일 하나만 바꿔도 관련 있는 모듈들을 다시 번들링해야 해서 프로젝트가 클수록 느려졌습니다.
    
- **Vite:** 수정한 파일과 가장 가까운 브라우저의 ESM 연결 고리만 교체합니다. 프로젝트 크기와 상관없이 **항상 즉각적으로 반영**됩니다.