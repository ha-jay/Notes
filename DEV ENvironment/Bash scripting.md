# bash scripting?
SH파일을 생성하여 BASH COMMAND를 통해 파일을 실행하면 여러 커맨드들이 실행되는 프로그램을 만들어 자동화를 하는것

# 스크립트 파일 작성 및 실행

## 파일생성 및 편집기 열기
- 파일생성 `touch filename.sh`
- 편집기 열기 
	- `nano filename.sh` : 컨트롤 O 저장 / 컨트롤 X 종료
	- `vi filename.sh` : i 입력모드, esc 명령어모드(입력종료), :wq 저장후종료 / :q! 저장하지않고 강제종료
	- `code .` vscode 편집기 open

## 실행권한 부여
파일을 만든 직후에는 실행 권한이 없습니다. `chmod` 명령어를 통해 실행 가능하게 만들어야 합니다.
`chmod +x myscript.sh`


## 스크립트 실행
`./myscript.sh`

`sh questionnaire.sh` : SH명령어를 통해 shell interpreter를 이용해 스크립트 실행
`bash asd.sh` : bash interpreter를 이용해 스크립트 실행


## 스크립트작성
```
codeally@450ce1864ec4:~/project$ touch script.sh 
codeally@450ce1864ec4:~/project$ chmod +x script.sh 
codeally@450ce1864ec4:~/project$ which bash 
/usr/bin/bash
```

nano script.sh 로 편집기 열어서 내용작성


```
#!/bin/bash 
#Program to run my other four programs

echo "hello world"
```

스크립트 실행
`./script.sh`

-> hello world 출력 확인


---
# 기본문법

### 세미콜론
콜론을 통해서 라인을 구분한다. 즉 콜론을 통해서 한줄에 여러 명령어를 작성가능하다
- `[[ 4 -ge 5 ]]; echo $?`

### `#`은 주석 
```bash
# 이것은 주석입니다
echo "helloworld"

```

### shebang
스크립트 파일을 실행할 인터프리터의 path표시하기
shebang을 추가하고나면, 파일명만 터미널에 입력하면, 해당 인터프리터를 통해서 스크립트가 실행된다.
```bash
#!/bin/bash
```


# 변수
## 변수 기초
### 변수 (Variables) 선언 및 사용
- **선언:** 대입 연산자(`=`) 앞뒤에 **공백이 없어야** 합니다.
    - 공백이 있으면 컴퓨터는 명령어로 인식을 합니다.
    - 변수는 대소문자를 구분합니다. 
    - 영문자,숫자,언더바만 사용가능합니다. 
    - 숫자로 시작하면 안됩니다. 
- 관례 : 현재세션에 잠깐 쓰는 지역변수는 소문자로 사용합니다. / 시스템에 영향을 주는 환경변수는 대문자로 작성합니다. 

- **사용:** 변수명 앞에 `$`를 붙입니다.

```BASH
name="Gemini"
echo "반갑습니다, $name님!"
```

### 값 할당 시 따옴표 활용 ''사용시 있는그대로 출력 ""사용시 변수치환
- **작은따옴표 (`' '`):** 안에 있는 내용을 **있는 그대로(문자열)** 처리합니다.
    - `GREETING='Hello $USER'` → 결과: `Hello $USER`
- **큰따옴표 (`" "`):** 안의 내용을 해석합니다. **변수를 치환**할 수 있습니다.
    - `GREETING="Hello $USER"` → 결과: `Hello goose` (실제 사용자 이름 출력)


### 변수사용시 중괄호의 활용 - 확실히 하기위해서는 변수에는 중괄호를 항상 쓰는 습관이 좋다.
변수 이름이 다른 글자와 붙어 있어 어디까지가 변수명인지 모호할 때 사용합니다.

- **예시:** `FRUIT=apple`
    - `echo "I like $FRUITs"` (컴퓨터는 `$FRUITs`라는 변수를 찾으려다가 실패합니다.)
    - `echo "I like ${FRUIT}s"` (정확히 `apple` 뒤에 `s`를 붙여 `apples`라고 출력합니다.)


### 변수 수정금지 readonly
`readonly 변수명` (한번 설정하면 값을 바꿀 수 없게 고정합니다.)
![[Pasted image 20260205123954.png]]

### 변수삭제
변수 삭제: `unset 변수명` (설정한 변수를 메모리에서 지웁니다.)
![[Pasted image 20260205124020.png]]

## 변수 생명주기 

부모와 자식의 관계

터미널을 열면 하나의 부모프로세스가 됩니다. 
터미널안에서 새로운프로그램 실행시 그 프로그램은 자식 프로세스가 되어 실행됩니다. 

지역변수 - 부모만 알고있는 비밀
- 부모는 자신의 기억을 자식에게 모두다 물려주지 않는다. 

환경변수 - 유산으로 물려주는 기억
- export Name=goose 라고 선언하는것은 이 변수를 유산목록에 등록하는것과 같다. 
- 부모는 자식에게 이러한 변수들의 복사본을 손에 쥐어줍니다. 



### 지역 변수 (Local Variables)

가장 수명이 짧은 변수입니다.

- **생성:** `NAME=goose`와 같이 일반적인 방식으로 선언할 때 생성됩니다.
- **범위:** 현재 실행 중인 **해당 터미널 창(Shell)** 안에서만 유효합니다.
- **소멸:** 
	- 터미널 창을 닫을 때.
    - `unset NAME` 명령어를 입력할 때.
    - **주의:** 현재 터미널에서 실행한 '자식 프로그램'(예: 쉘 스크립트 실행) 안으로는 이 변수가 전달되지 않습니다.
		- 자식프로세스는 부모프로세스의 지역변수에 접근이 불가합니다. 
		- 이것은 리눅스의 프로세스상속개념과 관련이 있습니다. 

### 환경 변수 (Environment Variables)

지역 변수보다 한 단계 더 넓은 생명주기를 가집니다.

- **생성:** `export NAME=goose`와 같이 **`export`** 키워드를 사용할 때 생성됩니다.
- **범위:** 현재 터미널은 물론, 그 터미널에서 실행되는 **모든 자식 프로세스**에 복사되어 전달됩니다.
- **소멸:** * 해당 변수를 처음 생성(export)한 부모 터미널 창을 닫을 때.
    - **한계:** 터미널을 새로 열면 다시 사라집니다. 즉, '현재 세션' 동안만 유지되는 것은 지역 변수와 같습니다.

---

### 3. 영구 변수 (Persistent Variables)

터미널을 껐다 켜도, 컴퓨터를 재부팅해도 살아남는 변수입니다.

- **생성:** 사용자의 홈 디렉토리에 있는 **설정 파일(`.bashrc` 또는 `.profile`)**에 `export` 구문을 직접 적어 넣어야 합니다.
- **작동 원리:** 터미널이 켜질 때마다 이 설정 파일을 읽어서 변수를 자동으로 다시 생성해 주는 방식입니다.
- **수명:** 설정 파일에서 해당 줄을 삭제하기 전까지 **영원히** 유지됩니다.


## 변수 확인
### set -  모든변수확인

쉘 세션에 정의된 **모든 변수(지역 변수 + 환경 변수)**와 쉘 함수까지 전부 보여줍니다.

- **명령어:** `set`
- **특징:** 양이 굉장히 많기 때문에 보통 `grep`과 함께 사용하여 특정 변수를 찾습니다.
    - 예: `set | grep MY_NAME`

### declare -p - 모든변수확인

```bash
declare -p
```

환경변수 포함 현재 쉘에서 생성된 변수 까지 모든 변수 보기


특정변수를 확인하려면 뒤에 변수명을 입력하세요.
```bash
declare -p J 
```


### 환경변수 확인하기 env or export or printenv

시스템 전체에 영향을 주거나 다른 프로그램으로 전달되는 **환경 변수**들만 골라서 보여줍니다.

- **명령어:** `env`
- **명령어 2:** `export` (변수 목록을 `export 변수명=값` 형식으로 보여주어 나중에 재사용하기 좋습니다.)
- **특징:** 개발 환경 설정(PATH, Editor, OS 종류 등)을 확인할 때 가장 많이 사용합니다.

-  명령어3 : `printenv` shell가 함께 제공된 환경변수확인


## 유용한 환경변수 
### RANDOM 
 RANDOM 변수는 0에서 32767 사이의 난수생성합니다.
 

## 변수 ${} 중괄호 사용법

### 대소문자 변경
```
STR="HELLO WORLD!"
echo ${STR,}   #=> "hELLO WORLD!" (lowercase 1st letter)
echo ${STR,,}  #=> "hello world!" (all lowercase)
```

```
STR="hello world!"
echo ${STR^}   #=> "Hello world!" (uppercase 1st letter)
echo ${STR^^}  #=> "HELLO WORLD!" (all uppercase)
```


### slicing - 문자열 자르기  `${변수:시작위치:길이}` 
변수의 내용 중 일부분만 추출할 때 사용합니다. `${변수:시작위치:길이}` 형식을 따릅니다.

- `${FILE:0:5}` : 0번째 인덱스부터 **5글자** 추출
- `${FILE:7}` : 7번째 인덱스부터 **끝까지** 추출
- `${FILE: -3}` : 뒤에서부터 **3글자** 추출 (마지막 확장자 확인 시 유용)

### replace 문자열 변경  `${STR/old/new}`
변수 안의 특정 문자를 다른 문자로 바꿉니다.

- `${STR/old/new}` : 처음 발견된 `old` 하나만 `new`로 교체
- `${STR//old/new}` : 발견된 **모든** `old`를 `new`로 교체
- `${STR/old/}` : `old`를 삭제 (공백으로 치환)

### strip 특정패턴 삭제
파일 경로명이나 확장자를 다룰 때 정말 많이 사용됩니다.

- **`#` (앞에서부터 삭제):**
    - `${PATH#*/}` : 앞에서부터 **가장 짧게** 일치하는 패턴 삭제
    - `${PATH##*/}` : 앞에서부터 **가장 길게** 일치하는 패턴 삭제 (파일명만 추출할 때 사용)
- **`%` (뒤에서부터 삭제):**
    - `${FILE%.*}` : 뒤에서부터 **가장 짧게** 일치하는 패턴 삭제 (확장자 제거 시 사용)
    - `${FILE%%.*}` : 뒤에서부터 **가장 길게** 일치하는 패턴 삭제

### 변수상태 체크 및 기본값 설정  `${VAR:-default}`
변수가 비어있을 경우를 대비해 예외 처리를 할 때 씁니다.

|                       |                                      |
| --------------------- | ------------------------------------ |
| **케이스**               | **의미**                               |
| `**${VAR:-default}**` | 변수가 비어있으면 `default`를 사용 (변수 값은 안 바뀜) |
| `**${VAR:=default}**` | 변수가 비어있으면 `default`를 **변수에 저장**하고 사용 |
| `**${VAR:?error}**`   | 변수가 비어있으면 `error` 메시지를 출력하고 스크립트 중단  |
| `**${VAR:+value}**`   | 변수가 설정되어 있을 때만 `value`를 사용           |
### 문자열 길이와 갯수  `${#VAR}`
`${#VAR}` : : 변수에 담긴 문자열의 글자 수를 반환합니다.

### 실전응용
파일 경로 `/home/user/data.tar.gz`  가 있을 때:
```
FILE="/home/user/data.tar.gz"

echo "파일명만: ${FILE##*/}"      # 결과: data.tar.gz
echo "폴더경로: ${FILE%/*}"       # 결과: /home/user
echo "첫번째 확장자 제거: ${FILE%.*}" # 결과: /home/user/data.tar
echo "모든 확장자 제거: ${FILE%%.*}"  # 결과: /home/user/data
```
이 `${ }` 문법들만 잘 활용해도 별도의 sed 나 awk 같은 외부 명령어 없이 쉘 자체 기능만으로 아주 빠른 문자열 처리가 가능합니다!
```
name="John"
echo ${name}
echo ${name/J/j}    #=> "john" (substitution)
echo ${name:0:2}    #=> "Jo" (slicing)
echo ${name::2}     #=> "Jo" (slicing)
echo ${name::-1}    #=> "Joh" (slicing)
echo ${name:(-1)}   #=> "n" (slicing from right)
echo ${name:(-2):1} #=> "h" (slicing from right)
echo ${food:-Cake}  #=> $food or "Cake"
```

## 커맨드라인 arguments 

커맨드라인 아규먼츠란?

변수를 '미리 약속된 상자'에 담아 보내는 것이라면, 아규먼츠는 프로그램을 실행할 때 **뒤에 공백을 두고 직접 던져주는 데이터**입니다.

터미널에서 명령어를 칠 때 뒤에 붙이는 모든 단어들이 아규먼츠입니다.

- 예: `ls -al /home`
    - `ls`: 실행할 프로그램
    - `al`: 첫 번째 아규먼트 (옵션)
    - `/home`: 두 번째 아규먼트 (대상 경로)


arguments 는 프로그램이 실행하는 순간에만 반짝하고 전달되는 일회성 데이터입니다. 변수와는 다릅니다. 


###  스크립트에서 아규먼츠 읽는 법 (위치 매개변수)

쉘 스크립트 내부에서는 던져진 아규먼츠들을 **숫자**로 인식합니다. 이를 '위치 매개변수'라고 부릅니다.

|          |                                                                                                                                                                                              |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **변수명**  | **의미                                                                                                                                                                                         |
| `**$0**` | **실행된 프로그램의 이름** 그                                                                                                                                                                           |
| `**$1**` | **첫 번째**                                                                                                                                                                                     |
| `**$2**` | **두 번째**                                                                                                                                                                                     |
| `**$#**` | 전달된 아규먼트의 **                                                                                                                                                                                 |
| `$*`     | 전달된 **모든** 아규먼트 목록(목록전체를 하나의 문자열                                                                                                                                                             |
| `$@`     | 전달된 모든 아큐먼트 목록(각각을 독립된 문자열로 유지함) ->이것을 훨                                                                                                                                                     |
| `$_`     | 마지막인수 / 직전실행한 명령어의 맨 마지막 argument를 기억합니다. 명령어를 실행할때마다 실시간 업데이트 됩니다. 똑같은 긴 결로명이나 파일명을 다시 타이핑하지않고 재사용하기위해 사용합니다. / 마지막 명령어의 인자가 없는경우에는 명령어 자체가 저장됩니다.  / 스크립트내부에서는 스크립트내 직전라인의 마지막 인자를 가져옵니다.  |

보통은 파일이름을 arguments로 받아 처리할때 많이 사용됩니다. 
`./process.sh data.txt` 라고 실행하면, 스크립트 안에서 `cat $1` 을 통해 `data.txt` 의 내용을 읽어오는 식이죠.


## 특별변수 - 종료상태코드



# 조건문

### 조건문 (If Statement)

조건을 비교할 때는 `[[ ]]`를 사용하는 것이 안전하고 기능이 많습니다.

```BASH
count=10
if [[ $count -gt 5 ]]; then
  echo "5보다 큽니다."
else
  echo "5보다 작거나 같습니다."
fi
```
# 반복문

### 반복문 (Loops)

리스트의 요소를 하나씩 꺼내어 처리합니다.

```BASH
for i in {1..5}; do
  echo "숫자: $i"
done
```

