# 변수 var, let, const
```js
// 변수 선언
let name = "John";        // 재할당 가능
const age = 30;           // 재할당 불가 (권장)
var oldWay = "legacy";    // 사용 지양

// 데이터 타입
const string = "Hello";
const number = 42;
const boolean = true;
const nullValue = null;
const undefinedValue = undefined;
const symbol = Symbol("unique");
const bigint = 1234567890123456789012345678901234567890n;

// 객체
const person = {
  name: "John",
  age: 30,
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
};

// 배열
const numbers = [1, 2, 3, 4, 5];
const mixed = [1, "two", true, { key: "value" }];

// typeof 연산자
console.log(typeof "hello");  // "string"
console.log(typeof 42);       // "number"
console.log(typeof true);     // "boolean"
console.log(typeof {});       // "object"
console.log(typeof []);       // "object" (주의!)
console.log(typeof null);     // "object" (버그, 역사적 이유)
```

## var, let, const의 차이와 스코프

### 1️⃣ 무엇인가? (What)

`var`, `let`, `const`는 JavaScript에서 **변수를 선언하는 키워드**입니다. 같은 목적이지만 **스코프, 재할당, 호이스팅** 측면에서 중요한 차이가 있습니다.

### 2️⃣ 왜 필요한가? (Why)

과거 JavaScript는 `var`만 존재했는데, 여러 문제점이 있었습니다:

- 함수 스코프만 지원 (블록 스코프 미지원)
- 재선언이 가능해서 실수로 변수 덮어쓰기 발생
- 호이스팅으로 인한 예상치 못한 동작

ES6(2015)에서 `let`과 `const`가 추가되어 **더 안전하고 예측 가능한 코드 작성**이 가능해졌습니다.


### 3️⃣ 배경 지식 (Background)  스코프(Scope)란?

변수가 **유효한 범위**를 의미합니다.

- **전역 스코프**: 어디서든 접근 가능
- **함수 스코프**: 함수 내부에서만 접근 가능
- **블록 스코프**: `{}` 블록 내부에서만 접근 가능

### 4️⃣ 어떻게 동작하는가? (How it works) - var, let , const

var의 동작 방식
```javascript
// 1. 함수 스코프
function example() {
  var x = 10;
  if (true) {
    var x = 20; // 같은 변수를 재선언!
    console.log(x); // 20
  }
  console.log(x); // 20 (덮어씌워짐!)
}

// 2. 호이스팅
console.log(name); // undefined (에러 아님!)
var name = 'John';

// 위 코드는 실제로 이렇게 동작:
// var name; // 호이스팅됨
// console.log(name); // undefined
// name = 'John';
```

 let의 동작 방식
```javascript
// 1. 블록 스코프
function example() {
  let x = 10;
  if (true) {
    let x = 20; // 새로운 변수 (블록 스코프)
    console.log(x); // 20
  }
  console.log(x); // 10 (원래 값 유지)
}

// 2. TDZ (Temporal Dead Zone)
console.log(age); // ReferenceError! (호이스팅은 되지만 초기화 전까지 접근 불가)
let age = 25;

// 3. 재할당 가능, 재선언 불가
let count = 1;
count = 2; // OK
let count = 3; // SyntaxError!
```

const의 동작 방식

```javascript
// 1. 블록 스코프 (let과 동일)
if (true) {
  const PI = 3.14;
  console.log(PI); // 3.14
}
// console.log(PI); // ReferenceError

// 2. 재할당 불가
const API_KEY = 'abc123';
API_KEY = 'xyz789'; // TypeError!

// 3. 선언 시 초기화 필수
const value; // SyntaxError! (초기값 없음)
const value = 10; // OK

// 4. 객체/배열의 내부는 변경 가능!
const user = { name: 'Alice' };
user.name = 'Bob'; // OK! (재할당이 아닌 속성 변경)
user.age = 30; // OK!
user = {}; // TypeError! (재할당 시도)

const arr = [1, 2, 3];
arr.push(4); // OK! [1, 2, 3, 4]
arr = []; // TypeError!
```


### 6️⃣ 실무에서 사용하는 방법 (Best Practice)

```javascript
// 1. 기본적으로 const 사용
const MAX_RETRY = 3;
const API_URL = 'https://api.example.com';

// 2. 재할당이 필요할 때만 let 사용
let currentPage = 1;
currentPage = 2; // OK

// 3. var는 사용하지 않기 (레거시 코드에만 존재)
```


### 실무 케이스 1: 반복문 - let 사용


```javascript
// ❌ var 사용 시 문제
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 출력: 3, 3, 3 (모두 같은 i를 참조)

// ✅ let 사용
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 출력: 0, 1, 2 (각각 독립적인 i)
```

### 🔥 실무 케이스 2: 설정 객체 불변성 - 불변 Object.freeze()


```javascript
// API 설정 (변경되면 안 됨)
const config = {
  timeout: 3000,
  retries: 3,
  baseURL: 'https://api.example.com'
};

// 만약 완전 불변으로 만들고 싶다면
const frozenConfig = Object.freeze(config);
frozenConfig.timeout = 5000; // 무시됨 (strict mode에서는 에러)
```

### 🔥 실무 케이스 3:  상태 관리 - 상태를 명시하는 객체이용

```javascript
// ❌ 나쁜 예
var orderStatus = 'pending';
if (payment) {
  var orderStatus = 'paid'; // 실수로 덮어씀
}

// ✅ 좋은 예
let orderStatus = 'pending';
if (payment) {
  orderStatus = 'paid'; // 의도적 재할당
}

// ✅ 더 좋은 예 (상태 전환)
const ORDER_STATUS = {
  PENDING: 'pending',
  PAID: 'paid',
  SHIPPED: 'shipped',
  COMPLETED: 'completed'
};

let currentStatus = ORDER_STATUS.PENDING;
currentStatus = ORDER_STATUS.PAID;
```


### CASE 4: 클로저와 스코프
```js
function createCounter() {
  let count = 0; // 외부에서 접근 불가 (private)
  
  return {
    increment: () => ++count,
    decrement: () => --count,
    getValue: () => count
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getValue());  // 2
// console.log(count); // ReferenceError
```

### CASE 5: 조건부 변수 선언 - if문 활용, 조건만족시에만 변수선언
avascript

```javascript
const userRole = 'admin';

if (userRole === 'admin') {
  const permissions = ['read', 'write', 'delete'];
  console.log(permissions); // OK
}

// console.log(permissions); // ReferenceError (블록 밖에서 접근 불가)
```

### CASE 6: 배열/객체 const의 활용

```javascript
// ERP 주문 데이터
const order = {
  id: 1001,
  customer: 'ABC Corp',
  items: []
};

// 주문 항목 추가 (OK)
order.items.push({ product: 'Widget A', qty: 10 });
order.items.push({ product: 'Widget B', qty: 5 });

// 총액 계산 추가 (OK)
order.total = order.items.reduce((sum, item) => sum + item.qty, 0);

console.log(order);
// { id: 1001, customer: 'ABC Corp', items: [...], total: 15 }

// ❌ 전체 교체는 불가
// order = { id: 1002 }; // TypeError
```



# 변수의 작동단계
## 호이스팅이란? 
호이스팅이란 코드가 실행되기전, 선언된 변수나 함수가 해당 스코프의 최상단으로 끌어올려진것처럼 동작하는 현상을 말합니다. 

변수나 함수의 선언이 먼저 hoisting되고, 추후 코드가 실행되면서 값이 할당되거나, 함수가 실행됩니다.  

hoisting : 변수선언은 scope범위에서 선언만 최상단으로 올라간다.


## 변수의 작동단계 - 선언 초기화 값할당

변수는 선언, 초기화, 값할당 3단계를 거칩니다. 
초기화되어야 사용가능합니다.

### var (선언-초기화 -> 값할당)
- 호이스팅되면서 초기값 undefined를 가집니다. 그러므로 초기화전에 사용가능합니다.
 *  선언된 변수는 값할당 구문을 만나면서 값이 할당됩니다.
 *  var로 선언한 변수는 재선언 가능합니다. 그렇기에 혼동을 줄이기위해 가능한 쓰지않는것이 좋습니다.  
 *  var 변수는 functional scope만 가집니다.  (함수외부에서만 참조불가)

### let (선언 -> 초기화-값할당)
 - let으로 선언한 변수는 호이스팅되면서  초기화가 되지않습니다. 그러므로 초기화전에 사용할수없습니다.
* 선언된 변수는 선언문 구문을 만나면서 값이 초기화됩니다.
* let로 선언한 변수는 재선언불가능합니다.
* let 변수는 block scope를 가집니다.  (function, if, while, for, try, catch..)

### const const (선언-초기화-값할당)
- const로 선언한 변수는 선언하면서 반드시 초기화까지 해야합니다. 그렇지않으면 구문에러발생합니다.
 *   const 변수는 재선언, 재할당불가능합니다. 오직 한번쓰고, 읽기전용으로만 사용됩니다.
 *   const 변수는 block scope를 가집니다.  (function, if, while, for, try, catch..)


## 요약
- 재선언 : var 가능 let, const불가
 * 다시쓰기 : var, let 가능, const 불가
 *   scope :
	 * var functional scope : var는 함수내부에서 선언되면, 함수에대해서 지역변수로 작동합니다. var는 함수외에 다른 block내부에서 선언되면 전역변수로 선언됩니다.
	 * let,const - block scope : 모든 block문에대해서 지역변수로 작동합니다.


## 코드 예시
### var의 재선언
```js
// var 재선언 -> 사실 재선언 하면안됨, var는 사용하지 않는게 좋다.

var varRedeclaration = "11";
var varRedeclaration; //선언만 다시하면 기존값이 바뀌지않는다.
console.log(varRedeclaration)  // return 11

var varRedeclaration = "22" // 재선언하고 값을 변경하면, 값이 변경된다.
```

### hoisting과 초기화
var
```js
  

//--------------var, let, const  --- hoisting과 초기화 살펴보기
 console.log(varVariable)  //undefined출력됩니다.
var varVariable = "var"

```

let
```js

 console.log(letVariable) 
 //ReferenceError: Cannot access 'nameLet' before initialization
//초기화가 되어있지않아서 사용불가합니다.
let letVariable = "let" ;
```
const
```js
console.log(constVariable) 
//ReferenceError: Cannot access 'constVariable' before initialization
//초기화가되어있지않아서 사용불가능합니다.
const constVariable = "const"
```

### 재선언

```js
//-------------------var, let, const 재선언 살펴보기
var var1 = 1;
var var1 = 2;
// console.log(var1) //2가출력됩니다. var는 재선언 가능합니다.

  

let let1 = 1;
let let1 = 2;  //SyntaxError: Identifier 'let1' has already been declared //이미 선언된 변수는 다시 선언할수 없습니다.

  

const const1 = 1;
const const1 = 2;  //SyntaxError: Identifier 'const1' has already been declared //이미 선언된 변수는 다시 선언할수 없습니다.
```

### scope
함수 -  var, let, const : 모든 선언에 대하여 scope가 생김
```js
//함수 
function func(){
  var var2 = "var";
  let let2 = "let";
  const const2 = "const"
}

console.log(var2)  //var2 is not defined

 console.log(let2)  //let2 is not defined

console.log(const2)  //const2 is not defined

  

function func2(){
  function nestedFunc2(){
    var var3 = "var";
    let let3 = "let";
    const const3 = "const"
  }

  console.log(var3)  //var3 is not defined
  console.log(let3)  //let3 is not defined
  console.log(const3)  //const3 is not defined
}

 func2();

```

block문
var는 전역변수로 선언됨 
let, const는 block scope 를가짐(지역변수).  
```js

//block문에대해서 

if (true) {
 var varif = "var";
 let letif = "let";
 const constif = "const"
}
console.log(varif)  //var는 전역변수로 선언됨.

console.log(letif) //letif is not defined

console.log(constif)  //constif is not defined

  

for (var i=0;i<1;i++){
  var varfor ="var";
  let letfor = "let";
  const constfor = "const"
}

console.log(i)  // var는 전역변수로 선언
console.log(varfor);  //var는 전역변수로 선언됨

console.log(letfor);  //letfor is not defined
 console.log(constfor); //constfor is not defined

  

for(let k =0; k<1;k++){
}
console.log(k);  //ReferenceError: k is not defined
```


# temporal dead zone
Hoisting & Scope때문에 발생하는  temporal deadZone(변수참조에러)

 - 함수내부에사 변수를 참조할때, 함수내부에 해당변수가 없으면 함수외부에서 찾아본다.  
 - 함수내부에 참조할 변수가 존재하면, 내부 변수를 참조한다.  
 - 함수내부변수는 함수범위내에서 hoisting되는데, 이때 초기화되지않은 선언(let)이 hoisting되고, 초기화구문을 만나기전에 해당변수가 참조되면 refernce에러가 발생한다.

```js
// 함수 내부에서 전역함수 참조

let test1 = 30;
function testfunc1(){
  // 함수내부에 test1 지역변수 없다
  console.log(test1); //return 30 -> 이문장은 전역 age를 참조한다
}
test1func();

  

// 함수내부에서 지역변수 참조
let test2 = 30;
function test2func(){
  // let선언-> 함수범위에서 hoisting, LET선언은 HOISTING때 초기화안됨
  let test2;   //code 파싱하면서 이곳에서 초기화한다. undefined를 할당.
  console.log(test2); //이문장은 함수범위에있는 test2를 참조한다 undefined값을 출력한다.
}

test2func();

  

// this is temporal dead ZONE
let test3 = 30;
function test3func(){
  // 함수가 호출되면, hoisting을 한다
  // 아래변수 let이 hoisting되지만, let변수는 hoisting때 초기화하지않는다.
  //초기화 되지않는 변수는 사용할수 없다.  
  console.log(test3);  //그러므로 Cannot access 'test3' before initialization 에러가 발생한다.  
  let test3=20;

}

 test3func();
```

# 지역변수와 전역변수 
## 변수의 수명

변수는 선언될때 시작됩니다.
-   local 변수는 함수가 호출되면 시작되고 종료되면 삭제됩니다.
-  전역 변수는 앱이 실행되면서 끝날때까지 메모리에 탑재됩니다.
	-     그러므로 전역변수는 최소한으로 사용하는게 좋습니다.
	-     가능하면 클래스, 함수, 조건문,ㅡ 반복문 안에서 필요한 변수를 따로 선언하는 게 좋은 습관입니다.
	-     웹브라우저에서는 전역 변수는 window이고 창을 닫으면 전역변수가 삭제됩니다.

## 환경에 따른 전역범위
 자브스크립트에서 전역범위는 자바스크립트 environment입니다.
 - 전역범위는 global객체입니다.
 -  전역환경에서 this는 global 객체를 의미합니다.
 -   this.variable 구문을 통해서 전역변수에 접근할수 있습니다.

  html에서 전역범위는 window객체입니다.
  -  전역환경에서 this는 window객체를 의미합니다.
  -   window.variable 구문을 통해 전역변수에 접근할수 있습니다.
  -  다른 윈도우나 다른 frame에서 선언된 전역변수에 접근할수도 있습니다.
  -  예를들면 iframe에서 전체문서에서 선언된 변수에 접근하려면 parent.variable로 접근할수 있습니다.
  -  의도하지않는한 전역변수를 생성하지마세요. 전역변수는 window변수를 덮어쓸수도 있습니다.

## 자바스크립트 전역, 지역 변수
자바스크립트 전역변수, 지역변수
  - 전역변수는 전역환경에 생성된 변수를 말합니다.
  - 지역변수는 외부환경에대해서 block scope를 가지는 환경에 생성된 변수를 말합니다.
  - 같은 이름의 변수라도 전역변수와 지역변수는 서로 다른 변수입니다.


  - 내부환경에서 외부환경의 변수는 참조가능합니다.
  - 외부환경에서 내부환경의 변수는 참조 불가능 합니다.  
  - 변수참조가 수행되면 해당 환경에서 선언된 변수를 먼저 참조합니다.
  - 없다면 외부환경에서 선언된 변수를 위계별로 찾아보고 참조합니다.
  - 최종 전역환경까지 찾아보고 참조할 변수가 선언되지않았다면 구문에러를 발생시킵니다 -> 선언되지않은 변수를 참조했다.

```js
let sameName = "samenameOuter";
let globalName = "global"
function fnc (){
  let sameName = "samenameLocal"
  let innerName = "inner"
  console.log(sameName) // 같은이름의 변수라도 전역과 로컬변수는 다른변수
  console.log(globalName)  //내부에서 외부 참조가능
  console.log(innerName)  // 내부에서 내부는 당연히 참조가능
}

fnc();
console.log(sameName);
console.log(globalName); //외부에서 외부환경의 변수 참조 당연히 가능
// console.log(innerName);//error -> 함수내부에 변수 참조불가
```

# 함수의 호이스팅
자바스크립트에서 **함수 호이스팅(Function Hoisting)**은 코드가 실행되기 전, 선언된 함수가 해당 스코프의 최상단으로 끌어올려진 것처럼 동작하는 현상을 말합니다.

하지만 모든 함수가 똑같이 호이스팅되는 것은 아닙니다. **함수를 어떻게 정의하느냐**에 따라 동작 방식이 완전히 달라지는데, 이 차이를 명확히 아는 것이 중요합니다.


## . 함수 선언문 (Function Declaration)

가장 전통적인 방식의 함수 정의입니다. 이 방식은 **함수 전체가 호이스팅**됩니다.

- **특징:** 함수의 이름과 몸체(내용)가 모두 메모리에 먼저 기록됩니다.
- **결과:** 함수 선언 전에도 해당 함수를 호출할 수 있습니다.

```JS
// 호출이 선언보다 앞에 있어도 에러가 나지 않습니다.
sayHello(); // 출력: "안녕하세요!"

function sayHello() {
  console.log("안녕하세요!");
}
```

## 2. 함수 표현식 (Function Expression)

함수를 변수에 할당하는 방식입니다. 이 방식은 **변수 호이스팅 규칙**을 따릅니다.

- **특징:** 변수 선언만 호이스팅되고, 함수 할당은 코드가 해당 줄에 도달했을 때 일어납니다.
- **결과:** 할당 전 호출 시 에러가 발생합니다.

### ① `var` 키워드를 사용한 표현식



```
printError(); // TypeError: printError is not a function

var printError = function() {
  console.log("에러가 날까요?");
};
// 설명: var는 호이스팅 시 undefined로 초기화되므로, "함수"가 아닌 "undefined"를 호출하는 꼴이 됩니다.
```

### ② `let`, `const` 키워드를 사용한 표현식 (권장)

JavaScript

```
printStrict(); // ReferenceError: Cannot access 'printStrict' before initialization

const printStrict = function() {
  console.log("안전한 호출!");
};
// 설명: TDZ(일시적 사각지대)에 갇혀 호출 자체가 금지됩니다. 훨씬 안전합니다.
```

## 3. 함수 호이스팅 vs 변수 호이스팅 (우선순위)

만약 같은 이름의 변수(`var`)와 함수 선언문이 동시에 있다면 어떻게 될까요?

- **함수가 변수보다 우선순위가 높습니다.** 호이스팅 단계에서 함수 선언문이 먼저 공간을 차지합니다.
```JS
console.log(typeof hobby); // "function"

var hobby = "coding";

function hobby() {
  console.log("I love programming");
}

console.log(typeof hobby); // "string" (코드가 실행되면서 값이 할당되었기 때문)
```

## 4. 왜 이런 현상이 발생하나요?

자바스크립트 엔진은 코드를 실행하기 전 **'컴파일 단계'**를 거칩니다. 이 과정에서 스코프에 있는 모든 선언(변수, 함수 등)을 미리 훑어서 메모리에 등록하기 때문입니다. 이를 **실행 컨텍스트 생성** 과정이라고 합니다.


# 스코프 체인
스코프 체인은 식별자(변수)를 찾기 위한 **"연결 리스트"**입니다. 
특정 스코프에서 변수를 찾을 때, 현재 스코프에 없으면 상위 스코프로 거슬러 올라가며 탐색하는 과정을 말합니다.

### 작동 원리

실행 컨텍스트의 내부에는 `Outer Environment Reference`(외부 환경 참조)가 있습니다. 이것이 바로 **"나를 감싸고 있는 부모 스코프"**를 가리키는 포인터입니다.

- **탐색 순서:** 현재 컨텍스트 ➔ 부모 컨텍스트 ➔ ... ➔ 전역 컨텍스트(GEC).
- **결과:** 전역 컨텍스트까지 올라갔는데도 변수를 못 찾으면 `ReferenceError`가 발생합니다.

# 클로저
정의 : **함수**가 정의된 시점의 **주변 환경(데이터)**을 세트로 묶어서 계속 가지고 있는 상태. 그 자체를 클로저라고 부릅니다.

클로저는 **"함수가 선언된 당시의 환경(Lexical Environment)을 기억하여, 함수가 외부에서 호출되어도 그 환경에 접근할 수 있는 기능"**을 말합니다.
쉽게 **"함수가 태어난 곳의 환경을 끝까지 기억하는 것"**입니다.

보통 함수가 실행을 마치면 그 안의 변수들은 사라집니다. 즉 메모리에서 변수는 사라집니다. 

하지만,  클로저를 이용하면, 메모리에서 변수가 사라지지않고 끝까지 기억합니다. 

### 클로저의 핵심용도
**"변수를 아무나 못 건드리게 숨기고 싶을 때"** 씁니다.

### 클로저 예시
```JS
function createCounter() {
  let count = 0; // 이 변수는 외부에서 절대 직접 수정 불가!

  return function() {
    count++; // 오직 이 함수를 통해서만 count가 1씩 증가함
    return count;
  };
}

const countUp = createCounter();
console.log(countUp()); // 1
console.log(countUp()); // 2
```

### 왜 메모리에서 안 사라질까요?

보통 함수 실행이 끝나면 컨텍스트가 사라지지만, **누군가(내부 함수)가 그 환경을 참조하고 있다면** 자바스크립트의 가비지 컬렉터(GC)는 해당 메모리를 해제하지 않고 유지합니다.

### 왜 이런 일이 생기나요? (동작 원리)

1. **스코프 권한:** 자바스크립트에서 자식 함수는 부모 함수의 변수를 볼 수 있는 권한이 있습니다.
2. **참조의 유지:** `outer`가 끝나서 죽으려고 할 때, 자식인 `inner`가 부모의 변수 `x`를 여전히 붙잡고(참조하고) 있습니다.
3. **가비지 컬렉터의 판단:** 자바스크립트 엔진은 **"누군가 참조하고 있다면 메모리에서 지우지 않는다"**는 규칙이 있습니다. 그래서 `outer`의 변수 `x`는 사라지지 않고 살아남습니다.

# 클로저 코드 예시 
**함수 내부의 데이터를 안전하게 보호하는 패턴**
### 1. 전역 변수 줄이기 (State 관리)

전역 변수는 누구나 접근할 수 있어 위험합니다. 클로저를 쓰면 특정 변수를 전역인 것처럼 '상태 유지'는 시키되, 아무나 건드리지 못하게 '보호'할 수 있습니다.
### 2. 함수 팩토리 (초기 설정 유지)

함수를 실행할 때 어떤 설정값을 미리 넣어두고, 그 설정값을 기억하는 새로운 함수를 만들 때 사용합니다.


```JavaScript
function multiply(x) {
  return function(y) {
    return x * y; // x는 부모의 환경에서 가져와 기억함
  };
}

const double = multiply(2); // x에 2가 고정된 클로저 생성
const triple = multiply(3); // x에 3이 고정된 클로저 생성

console.log(double(10)); // 20
console.log(triple(10)); // 30
```

---







