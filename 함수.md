# 함수정의
함수를 정의하는 방법은 여러 가지가 있으며, 각 방법은 **호이스팅(Hoisting)** 여부나 **`this` 바인딩** 방식에서 차이가 납니다. 

핵심적인 4가지 방법을 정리해 드릴게요.

## 함수선언문 - function


`function` 키워드 뒤에 함수 이름을 명시합니다.

**특징:** **호이스팅**이 발생합니다. 즉, 함수를 정의하기 전 줄에서도 호출이 가능합니다. 자바스크립트 엔진이 실행 전 '생성 단계'에서 함수 전체를 메모리에 미리 등록하기 때문입니다.

```js
sayHello(); // 실행 가능 (호이스팅)

function sayHello() {
  console.log("안녕하세요!");
}
```

```js
// --------------function declaration statement----------
function printObj(o) { //함수를선언해서 변수 printprops에 assign한다. 
    //parameters - 파라미터는 함수에서 local변수로 작동한다. 
    for (let p in o)
        console.log(p + ": " + o[p]);
} //return문이 없으면 undefined를 반환

const obj = {
    name: "jay",
    "high perfomance": "true"
}
printObj(obj);




console.log(distance(2, 2, 7, 8)); //함수선언문은 hoisting된다. 그래서 선언문앞에서 호출해도 잘 작동한다. 
function distance(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy); //함수수행멈추고, 리턴문내부의 표현식을 호출자(caller)에게 리턴
} //return문안에 표현식이 없으면 undefined를 반환

```

## 함수표현식
함수를 변수에 할당하는 방식입니다. 
자바스크립트에서 함수는 '값'으로 취급되기 때문에 가능합니다.

**특징:** 변수 호이스팅 규칙을 따릅니다. `const`나 `let`으로 선언하면 함수 정의 전에는 호출할 수 없습니다.

표현식함수는 이름이 없다. 하지만 변수에 할당할수 있다.
반면에 표현식방식은 hoisting되지않는다. 
변수에할당하더라도 변수 hoisting룰에따라서 변수에할당된값은 hoisting되지않는다. 
그러므로 표현식방식으로는 선언전에 호출해도 작동하지 않는다.
```js
// sayHi(); // 에러 발생!

const sayHi = function() {
  console.log("반갑습니다!");
};

sayHi(); // 정의된 이후에만 호출 가능
```

표현식 함수는 다른함수의 인자로 사용할 수 있다. 
```js
console.log([23, 2, 4734, 5, 345, 243, 6].sort(function(a, b) {
    return a - b
}))
```

표현식 함수는 정의하고 바로 호출가능하다. (익명함수라 한다)
```js
console.log((function(x) {
    return Math.sqrt(x)
}(7)));
```

표현식함수가 이름(fact)을 가지면, 해당변수(fact)는 함수(f)에 대해서 local로 작동한다. 
이러한 방식은 재귀용법에 유용하다.
```js
const f = function fact(x) {
    if (x < 1) return 1;
    else return x * fact(x - 1)
}

console.log(f(5)); //5*4*3*2*1
```

표현식함수가 이름이 없을때, 재귀용법에 사용하기위해서 arguments객체의 callee(호출되어진함수를 의미)속성을 사용
```js
const fc = function(x) {
    if (x < 1) return 1;
    else return x * arguments.callee(x - 1)
};

console.log(fc(5)); //5*4*3*2*1
```
## 화살표함수
- **특징:** * 문법이 짧습니다.
    - **자신만의 `this`를 가지지 않습니다.** (상위 스코프의 `this`를 그대로 물려받음 - Lexical this)
    - 생성자 함수로 사용할 수 없습니다.

```js
// 기본형
const add = (a, b) => {
  return a + b;
};

// 중괄호와 return 생략 가능 (한 줄일 때만)
const multiply = (a, b) => a * b;

// 매개변수가 하나라면 소괄호도 생략 가능
const square = x => x * x;
```

## Function 생성자함수
```js
const sum = new Function('a', 'b', 'return a + b');
console.log(sum(10, 20)); // 30
```

## 🧐 어떤 것을 사용해야 할까요?

- 일반적인 경우에는 **화살표 함수**를 가장 많이 씁니다. (간결함 때문)
    
- 하지만 객체의 메서드(Method)를 정의하거나, 특정 상황에서 `this`를 동적으로 다뤄야 한다면 일반 **함수 표현식**이나 **선언문**이 필요할 수 있습니다.


# 중첩함수
## 1. 스코프 체인과 접근 권한

중첩 함수의 가장 큰 특징은 **"내부 함수가 외부 함수의 변수(Local Variables)와 파라미터에 접근할 수 있다"**는 점입니다.

- **동작 원리:** 내부 함수가 실행될 때, 자신의 스코프에서 변수를 찾지 못하면 외부 함수의 스코프로 올라가 탐색합니다. (앞서 배운 스코프 체인)
    
- **캡슐화:**  내부 함수는 오직 외부함수 안에서만 의미가 있을 때, 이를 밖으로 노출하지 않고 안으로 숨기는 효과가 있습니다.


```js
function outerf(x, y) {
    let originX = 0, originY=0; dx = x-originX, dy= y-originY;
    let result;

    function innerf() { //외부함수를 호출한다고 , 내부함수선언문이 호출되는게 아니다.
        result = Math.sqrt(sqaure(dx) + sqaure(dy))
    }
    innerf(); //함수안에서 따로 호출을 해줘야한다.  
    return result;
}
console.log(outerf(2, 2));
```

위 함수를 좀더 간결하게 해보자
```js
function hypotenuse(a, b) {
    function square(x) {
        return x * x;
    }
    return Math.sqrt(square(a) + square(b));
}
console.log(hypotenuse(2, 2));
```

## 조건문/반복문 내 함수 선언 (Block-level Functions)
과거 자바스크립트(ES5 이하) 명세에서는 함수 선언문이 블록(`{}`) 내부에 있는 것을 금지했지만, 현대 자바스크립트(ES6+)에서는 **블록 스코프 함수**로 인정됩니다.

**핵심 차이:**
- **일반 모드:** 블록 밖에서도 함수가 보일 수 있어 혼란을 야기함.
- **엄격 모드 (`'use strict';`):** 함수는 오직 해당 블록(`if`, `for` 등) 내부에서만 존재하며 밖에서는 사용할 수 없습니다.

따라서 로직상 블록 안에서 함수가 필요하다면 **함수 표현식**을 사용하는 것이 훨씬 안전하고 예측 가능합니다.




